<html>
<head>
<meta http-equiv="Content-Type" content="text/html; charset=CP850">
<style type="text/css">
span.lineno { color: white; background: #aaaaaa; border-right: solid white 12px }
span.nottickedoff { background: yellow}
span.istickedoff { background: white }
span.tickonlyfalse { margin: -1px; border: 1px solid #f20913; background: #f20913 }
span.tickonlytrue  { margin: -1px; border: 1px solid #60de51; background: #60de51 }
span.funcount { font-size: small; color: orange; z-index: 2; position: absolute; right: 20 }
span.decl { font-weight: bold }
span.spaces    { background: white }
</style>
</head>
<body>
<pre>
<span class="decl"><span class="nottickedoff">never executed</span> <span class="tickonlytrue">always true</span> <span class="tickonlyfalse">always false</span></span>
</pre>
<pre>
<span class="lineno">    1 </span>module Lib (
<span class="lineno">    2 </span> generateRandom,
<span class="lineno">    3 </span> isValid,
<span class="lineno">    4 </span> movesNumbers,
<span class="lineno">    5 </span> isValidAux
<span class="lineno">    6 </span>) where
<span class="lineno">    7 </span>
<span class="lineno">    8 </span>import System.IO
<span class="lineno">    9 </span>import Control.Monad
<span class="lineno">   10 </span>import System.Random
<span class="lineno">   11 </span>import Data.Maybe
<span class="lineno">   12 </span>import Data.List
<span class="lineno">   13 </span>import Text.Read
<span class="lineno">   14 </span>
<span class="lineno">   15 </span>data State = State ([String], [(Int, Int)], [(Int, Int)], Int) deriving (<span class="decl"><span class="istickedoff">Show</span></span>, <span class="decl"><span class="nottickedoff"><span class="decl"><span class="istickedoff"><span class="decl"><span class="nottickedoff">Read</span></span></span></span></span></span>)
<span class="lineno">   16 </span>data Move = Move ((Int, Int), (Int,Int), String) deriving (<span class="decl"><span class="istickedoff">Show</span></span>, <span class="decl"><span class="nottickedoff"><span class="decl"><span class="istickedoff"><span class="decl"><span class="nottickedoff">Read</span></span></span></span></span></span>)
<span class="lineno">   17 </span>
<span class="lineno">   18 </span>-- Parses State and [Moves] from a filePath
<span class="lineno">   19 </span>-- and passes the data to isValidAux
<span class="lineno">   20 </span>isValid :: String -&gt; IO (String)
<span class="lineno">   21 </span><span class="decl"><span class="istickedoff">isValid filePath = do</span>
<span class="lineno">   22 </span><span class="spaces">    </span><span class="istickedoff">contents &lt;- readFile filePath</span>
<span class="lineno">   23 </span><span class="spaces">    </span><span class="istickedoff">let linesAsList = lines contents</span>
<span class="lineno">   24 </span><span class="spaces">    </span><span class="istickedoff">let state = (&quot;State &quot; ++ (head linesAsList))</span>
<span class="lineno">   25 </span><span class="spaces">    </span><span class="istickedoff">let moves = [&quot;Move &quot; ++ x | x &lt;- (tail linesAsList)]</span>
<span class="lineno">   26 </span><span class="spaces">    </span><span class="istickedoff">let maybeState = readMaybe state :: Maybe State</span>
<span class="lineno">   27 </span><span class="spaces">    </span><span class="istickedoff">let maybeMoves = [readMaybe x :: Maybe Move | x &lt;- moves]</span>
<span class="lineno">   28 </span><span class="spaces">    </span><span class="istickedoff">-- Getting maybe state</span>
<span class="lineno">   29 </span><span class="spaces">    </span><span class="istickedoff">if (isNothing maybeState)</span>
<span class="lineno">   30 </span><span class="spaces">    </span><span class="istickedoff">then return &quot;ParsingError&quot;</span>
<span class="lineno">   31 </span><span class="spaces">    </span><span class="istickedoff">-- Getting maybe moves</span>
<span class="lineno">   32 </span><span class="spaces">    </span><span class="istickedoff">else if any (&amp;&amp;True) [isNothing x | x &lt;- maybeMoves]</span>
<span class="lineno">   33 </span><span class="spaces">    </span><span class="istickedoff">then return &quot;ParsingError&quot;</span>
<span class="lineno">   34 </span><span class="spaces">    </span><span class="istickedoff">-- Checking for empty moves list or invalid state</span>
<span class="lineno">   35 </span><span class="spaces">    </span><span class="istickedoff">else if (null maybeMoves)</span>
<span class="lineno">   36 </span><span class="spaces">    </span><span class="istickedoff">then return &quot;ParsingError&quot;</span>
<span class="lineno">   37 </span><span class="spaces">    </span><span class="istickedoff">else if (errorInState (read state :: State) /= 0)</span>
<span class="lineno">   38 </span><span class="spaces">    </span><span class="istickedoff">then return &quot;ParsingError&quot;</span>
<span class="lineno">   39 </span><span class="spaces">    </span><span class="istickedoff">else return (isValidAux (read state :: State) [ read x :: Move | x &lt;- moves])</span></span> 
<span class="lineno">   40 </span>
<span class="lineno">   41 </span>-- Passes the State and list of Move's on to isValidAux',
<span class="lineno">   42 </span>-- along side a counter used to keep track of the amount of moves played
<span class="lineno">   43 </span>isValidAux :: State -&gt; [Move] -&gt; String
<span class="lineno">   44 </span><span class="decl"><span class="istickedoff">isValidAux state [] = removeFirstWord (show state)</span>
<span class="lineno">   45 </span><span class="spaces"></span><span class="istickedoff">isValidAux (State (cards, piecesA, piecesB, turn)) (move:moves) </span>
<span class="lineno">   46 </span><span class="spaces">    </span><span class="istickedoff">| (null piecesA || null piecesB) &amp;&amp; not (null (<span class="nottickedoff">move</span>:<span class="nottickedoff">moves</span>)) = &quot;NonValid &quot; ++ removeFirstWord (show move)</span>
<span class="lineno">   47 </span><span class="spaces">    </span><span class="istickedoff">| errorInMove cards move piecesA piecesB turn = &quot;NonValid &quot; ++ removeFirstWord (show move)</span>
<span class="lineno">   48 </span><span class="spaces">    </span><span class="istickedoff">| <span class="tickonlytrue">otherwise</span> = isValidAux newState moves</span>
<span class="lineno">   49 </span><span class="spaces">    </span><span class="istickedoff">where</span>
<span class="lineno">   50 </span><span class="spaces">        </span><span class="istickedoff">newState = applyMove (State (cards, piecesA, piecesB, turn)) move</span></span> 
<span class="lineno">   51 </span>
<span class="lineno">   52 </span>-- Removes everything up to and including the first space
<span class="lineno">   53 </span>removeFirstWord :: String -&gt; String 
<span class="lineno">   54 </span><span class="decl"><span class="istickedoff">removeFirstWord (x:xs)</span>
<span class="lineno">   55 </span><span class="spaces">    </span><span class="istickedoff">| (x == ' ') = xs</span>
<span class="lineno">   56 </span><span class="spaces">    </span><span class="istickedoff">| <span class="tickonlytrue">otherwise</span> = removeFirstWord xs</span></span>
<span class="lineno">   57 </span>
<span class="lineno">   58 </span>-- Takes a State and a Move, and returns a new State where the Move has been performed
<span class="lineno">   59 </span>applyMove :: State -&gt; Move -&gt; State
<span class="lineno">   60 </span><span class="decl"><span class="istickedoff">applyMove (State (cards, piecesA, piecesB, turn)) (Move (start, end, card))</span>
<span class="lineno">   61 </span><span class="spaces">    </span><span class="istickedoff">= (State (cards', piecesA', piecesB', turn'))</span>
<span class="lineno">   62 </span><span class="spaces">    </span><span class="istickedoff">where</span>
<span class="lineno">   63 </span><span class="spaces">        </span><span class="istickedoff">cards' = sortCards (swapCards cards card)</span>
<span class="lineno">   64 </span><span class="spaces">        </span><span class="istickedoff">piecesA' = sortPieces (getFirst (applyPieces start end turn piecesA piecesB))</span>
<span class="lineno">   65 </span><span class="spaces">        </span><span class="istickedoff">piecesB' = sortPieces (getSecond (applyPieces start end turn piecesA piecesB))</span>
<span class="lineno">   66 </span><span class="spaces">        </span><span class="istickedoff">turn' = if turn == 0 then 1 else 0</span></span>
<span class="lineno">   67 </span>
<span class="lineno">   68 </span>-- Swaps played card with the last card
<span class="lineno">   69 </span><span class="decl"><span class="istickedoff">swapCards (x:xs) card</span>
<span class="lineno">   70 </span><span class="spaces">    </span><span class="istickedoff">| x == card = (last xs):(swapCards xs card)</span>
<span class="lineno">   71 </span><span class="spaces">    </span><span class="istickedoff">| null xs = card:[]</span>
<span class="lineno">   72 </span><span class="spaces">    </span><span class="istickedoff">| <span class="tickonlytrue">otherwise</span> = x:(swapCards xs card)</span></span>
<span class="lineno">   73 </span>
<span class="lineno">   74 </span>-- Sorts first and second, and third and fourth cards, lexicographically repectively
<span class="lineno">   75 </span>sortCards :: [String] -&gt; [String]
<span class="lineno">   76 </span><span class="decl"><span class="istickedoff">sortCards cards = (sort(take 2 cards)) ++ (sort((cards !! 2):(cards !! 3):[])) ++ (last cards):[]</span></span>
<span class="lineno">   77 </span>
<span class="lineno">   78 </span>-- Checks if any player has won
<span class="lineno">   79 </span>applyPieces :: (Int, Int) -&gt; (Int, Int) -&gt; Int -&gt; [(Int, Int)] -&gt; [(Int, Int)] -&gt; ([(Int, Int)], [(Int, Int)])
<span class="lineno">   80 </span><span class="decl"><span class="istickedoff">applyPieces start end turn piecesA piecesB</span>
<span class="lineno">   81 </span><span class="spaces">    </span><span class="istickedoff">| turn == 0 &amp;&amp; (head newPiecesA) == (4,2)  = (newPiecesA, [])</span>
<span class="lineno">   82 </span><span class="spaces">    </span><span class="istickedoff">| turn == 1 &amp;&amp; (head newPiecesB) == (0,2) = ([], newPiecesB)</span>
<span class="lineno">   83 </span><span class="spaces">    </span><span class="istickedoff">| turn == 0 &amp;&amp; end == (head newPiecesB) = (newPiecesA, [])</span>
<span class="lineno">   84 </span><span class="spaces">    </span><span class="istickedoff">| turn == 1 &amp;&amp; end == (head newPiecesA) = ([], newPiecesB)</span>
<span class="lineno">   85 </span><span class="spaces">    </span><span class="istickedoff">| turn == 0 &amp;&amp; elem end (tail newPiecesB) = (newPiecesA, (hitDetected piecesB end))</span>
<span class="lineno">   86 </span><span class="spaces">    </span><span class="istickedoff">| turn == 1 &amp;&amp; elem end (tail newPiecesA) = ((hitDetected piecesA end), newPiecesB)</span>
<span class="lineno">   87 </span><span class="spaces">    </span><span class="istickedoff">| <span class="tickonlytrue">otherwise</span> = (newPiecesA, newPiecesB)</span>
<span class="lineno">   88 </span><span class="spaces">    </span><span class="istickedoff">where  -- Getting the new positions</span>
<span class="lineno">   89 </span><span class="spaces">        </span><span class="istickedoff">newPiecesA = applyPiecesA start end turn piecesA</span>
<span class="lineno">   90 </span><span class="spaces">        </span><span class="istickedoff">newPiecesB = applyPiecesB start end turn piecesB</span></span>
<span class="lineno">   91 </span>
<span class="lineno">   92 </span>-- Sorts a players pieces lexicographically
<span class="lineno">   93 </span>sortPieces :: [(Int, Int)] -&gt; [(Int, Int)]
<span class="lineno">   94 </span><span class="decl"><span class="istickedoff">sortPieces [] = []</span>
<span class="lineno">   95 </span><span class="spaces"></span><span class="istickedoff">sortPieces (x:xs)</span>
<span class="lineno">   96 </span><span class="spaces">    </span><span class="istickedoff">| null xs = [x]</span>
<span class="lineno">   97 </span><span class="spaces">    </span><span class="istickedoff">| <span class="tickonlytrue">otherwise</span> = x:(sort xs)</span></span>
<span class="lineno">   98 </span>
<span class="lineno">   99 </span>-- Updating player A's pieces
<span class="lineno">  100 </span>applyPiecesA :: (Int, Int) -&gt; (Int, Int) -&gt; Int -&gt; [(Int, Int)] -&gt; [(Int, Int)]
<span class="lineno">  101 </span><span class="decl"><span class="istickedoff">applyPiecesA start end turn piecesA</span>
<span class="lineno">  102 </span><span class="spaces">    </span><span class="istickedoff">| turn == 1 = piecesA</span>
<span class="lineno">  103 </span><span class="spaces">    </span><span class="istickedoff">| <span class="tickonlytrue">otherwise</span> = swapPieces piecesA start end</span></span>
<span class="lineno">  104 </span>
<span class="lineno">  105 </span>-- Updating player B's pieces
<span class="lineno">  106 </span>applyPiecesB :: (Int, Int) -&gt; (Int, Int) -&gt; Int -&gt; [(Int, Int)] -&gt; [(Int, Int)]
<span class="lineno">  107 </span><span class="decl"><span class="istickedoff">applyPiecesB start end turn piecesB</span>
<span class="lineno">  108 </span><span class="spaces">    </span><span class="istickedoff">| turn ==  0 = piecesB</span>
<span class="lineno">  109 </span><span class="spaces">    </span><span class="istickedoff">| <span class="tickonlytrue">otherwise</span> = swapPieces piecesB start end</span></span>
<span class="lineno">  110 </span>
<span class="lineno">  111 </span>-- Swaps start with end and returns the new list
<span class="lineno">  112 </span>swapPieces :: [(Int, Int)] -&gt; (Int, Int) -&gt; (Int, Int) -&gt; [(Int, Int)]
<span class="lineno">  113 </span><span class="decl"><span class="istickedoff">swapPieces [] _ _ = []</span>
<span class="lineno">  114 </span><span class="spaces"></span><span class="istickedoff">swapPieces (x:xs) start end</span>
<span class="lineno">  115 </span><span class="spaces">    </span><span class="istickedoff">| x == start = end:(swapPieces xs start <span class="nottickedoff">end</span>)</span>
<span class="lineno">  116 </span><span class="spaces">    </span><span class="istickedoff">| <span class="tickonlytrue">otherwise</span> = x:(swapPieces xs start end)</span></span>
<span class="lineno">  117 </span>
<span class="lineno">  118 </span>-- Removes a piece from a list
<span class="lineno">  119 </span>hitDetected :: [(Int, Int)] -&gt; (Int, Int) -&gt; [(Int, Int)]
<span class="lineno">  120 </span><span class="decl"><span class="istickedoff">hitDetected (x:xs) end</span>
<span class="lineno">  121 </span><span class="spaces">    </span><span class="istickedoff">| null xs = []</span>
<span class="lineno">  122 </span><span class="spaces">    </span><span class="istickedoff">| x == end = (hitDetected xs end)</span>
<span class="lineno">  123 </span><span class="spaces">    </span><span class="istickedoff">| <span class="tickonlytrue">otherwise</span> = x:(hitDetected xs end)</span></span>
<span class="lineno">  124 </span>
<span class="lineno">  125 </span>-- Gets first element i (Int, Int) tuple
<span class="lineno">  126 </span>getFirst :: ([(Int, Int)], [(Int, Int)]) -&gt; [(Int, Int)]
<span class="lineno">  127 </span><span class="decl"><span class="istickedoff">getFirst (a,_) = a</span></span>
<span class="lineno">  128 </span>
<span class="lineno">  129 </span>-- Gets second element i (Int, Int) tuple
<span class="lineno">  130 </span>getSecond :: ([(Int, Int)], [(Int, Int)]) -&gt; [(Int, Int)]
<span class="lineno">  131 </span><span class="decl"><span class="istickedoff">getSecond (_,a) = a</span></span>
<span class="lineno">  132 </span>
<span class="lineno">  133 </span>-- Passes on the state to be checked in a lot of ways
<span class="lineno">  134 </span>errorInState :: State -&gt; Int
<span class="lineno">  135 </span><span class="decl"><span class="istickedoff">errorInState (State (cards, piecesA, piecesB, turn))</span>
<span class="lineno">  136 </span><span class="spaces">    </span><span class="istickedoff">| errorInCards cards = 1</span>
<span class="lineno">  137 </span><span class="spaces">    </span><span class="istickedoff">| piecesA /= (sortPieces piecesA) || piecesB /= (sortPieces piecesB) = 2</span>
<span class="lineno">  138 </span><span class="spaces">    </span><span class="istickedoff">| (errorInPieces piecesA) || (errorInPieces piecesB) = 3</span>
<span class="lineno">  139 </span><span class="spaces">    </span><span class="istickedoff">| hasDuplicatePieces (piecesA++piecesB) = 4</span>
<span class="lineno">  140 </span><span class="spaces">    </span><span class="istickedoff">| (turn /= 0) &amp;&amp; (turn /= 1) = 5</span>
<span class="lineno">  141 </span><span class="spaces">    </span><span class="istickedoff">| <span class="tickonlytrue">otherwise</span> = 0</span></span>
<span class="lineno">  142 </span>
<span class="lineno">  143 </span>-- Checks for 5 cards in total
<span class="lineno">  144 </span>errorInCards :: [String] -&gt; Bool
<span class="lineno">  145 </span><span class="decl"><span class="istickedoff">errorInCards [] = True</span>
<span class="lineno">  146 </span><span class="spaces"></span><span class="istickedoff">errorInCards cards</span>
<span class="lineno">  147 </span><span class="spaces">    </span><span class="istickedoff">| duplicateCards cards = True</span>
<span class="lineno">  148 </span><span class="spaces">    </span><span class="istickedoff">| cards /= (sortCards cards) = True</span>
<span class="lineno">  149 </span><span class="spaces">    </span><span class="istickedoff">| <span class="tickonlyfalse">length cards /= 5</span> = <span class="nottickedoff">True</span></span>
<span class="lineno">  150 </span><span class="spaces">    </span><span class="istickedoff">| <span class="tickonlytrue">otherwise</span> = errorInCards' [getLegalMoves card | card &lt;- cards]</span></span>
<span class="lineno">  151 </span>
<span class="lineno">  152 </span>duplicateCards :: [String] -&gt; Bool
<span class="lineno">  153 </span><span class="decl"><span class="istickedoff">duplicateCards [] = False</span>
<span class="lineno">  154 </span><span class="spaces"></span><span class="istickedoff">duplicateCards (x:xs)</span>
<span class="lineno">  155 </span><span class="spaces">    </span><span class="istickedoff">| elem x xs = True</span>
<span class="lineno">  156 </span><span class="spaces">    </span><span class="istickedoff">| <span class="tickonlytrue">otherwise</span> = duplicateCards xs</span></span>
<span class="lineno">  157 </span>
<span class="lineno">  158 </span>-- Checks if all Cards in state are valid cards
<span class="lineno">  159 </span>-- (Nonvalid names gives an empty list)
<span class="lineno">  160 </span>errorInCards' :: [[(Int, Int)]] -&gt; Bool
<span class="lineno">  161 </span><span class="decl"><span class="istickedoff">errorInCards' [] = False</span>
<span class="lineno">  162 </span><span class="spaces"></span><span class="istickedoff">errorInCards' (card:cards)</span>
<span class="lineno">  163 </span><span class="spaces">    </span><span class="istickedoff">| null card = True</span>
<span class="lineno">  164 </span><span class="spaces">    </span><span class="istickedoff">| <span class="tickonlytrue">otherwise</span> = errorInCards' cards</span></span>
<span class="lineno">  165 </span>
<span class="lineno">  166 </span>-- Checks if all pieces have valid coordinates
<span class="lineno">  167 </span>errorInPieces :: [(Int, Int)] -&gt; Bool
<span class="lineno">  168 </span><span class="decl"><span class="istickedoff">errorInPieces [] = False</span>
<span class="lineno">  169 </span><span class="spaces"></span><span class="istickedoff">errorInPieces ((x1, x2):pieces)</span>
<span class="lineno">  170 </span><span class="spaces">    </span><span class="istickedoff">| (length pieces) &gt; 4 = True</span>
<span class="lineno">  171 </span><span class="spaces">    </span><span class="istickedoff">| (x1 &lt; 0) || (x2 &lt; 0) || (x1 &gt; 4) || (x2 &gt; 4) = True</span>
<span class="lineno">  172 </span><span class="spaces">    </span><span class="istickedoff">| <span class="tickonlytrue">otherwise</span> = errorInPieces pieces</span></span>
<span class="lineno">  173 </span>
<span class="lineno">  174 </span>-- Checks if any two pieces are on the same tile on the board
<span class="lineno">  175 </span>hasDuplicatePieces :: [(Int, Int)] -&gt; Bool
<span class="lineno">  176 </span><span class="decl"><span class="istickedoff">hasDuplicatePieces [] = False</span>
<span class="lineno">  177 </span><span class="spaces"></span><span class="istickedoff">hasDuplicatePieces (x:xs)</span>
<span class="lineno">  178 </span><span class="spaces">    </span><span class="istickedoff">| elem x xs = True</span>
<span class="lineno">  179 </span><span class="spaces">    </span><span class="istickedoff">| <span class="tickonlytrue">otherwise</span> = hasDuplicatePieces xs</span></span>
<span class="lineno">  180 </span>
<span class="lineno">  181 </span>-- Checks if anything is fundamentally invalid in the move
<span class="lineno">  182 </span>errorInMove :: [String] -&gt; Move -&gt; [(Int, Int)] -&gt; [(Int, Int)] -&gt; Int -&gt; Bool
<span class="lineno">  183 </span><span class="decl"><span class="istickedoff">errorInMove cards (Move (start, end, card)) piecesA piecesB turn</span>
<span class="lineno">  184 </span><span class="spaces">    </span><span class="istickedoff">| (turn == 0) &amp;&amp; not (card `elem` (take 2 cards)) = True</span>
<span class="lineno">  185 </span><span class="spaces">    </span><span class="istickedoff">| (turn == 1) &amp;&amp; not (card `elem` ([cards !! 2] ++ [cards !! 3])) = True</span>
<span class="lineno">  186 </span><span class="spaces">    </span><span class="istickedoff">| (turn == 0) &amp;&amp; not (start `elem` piecesA) = True</span>
<span class="lineno">  187 </span><span class="spaces">    </span><span class="istickedoff">| (turn == 1) &amp;&amp; not (start `elem` piecesB) = True</span>
<span class="lineno">  188 </span><span class="spaces">    </span><span class="istickedoff">| (turn == 0) &amp;&amp; (end `elem` piecesA) = True</span>
<span class="lineno">  189 </span><span class="spaces">    </span><span class="istickedoff">| (turn == 1) &amp;&amp; (end `elem` piecesB) = True</span>
<span class="lineno">  190 </span><span class="spaces">    </span><span class="istickedoff">| <span class="tickonlytrue">otherwise</span> = errorInMove' start end (getLegalMoves card) turn</span></span>
<span class="lineno">  191 </span>
<span class="lineno">  192 </span>-- Checks if the move is possible, given the start- and end position,
<span class="lineno">  193 </span>-- and the legal moves of the card played
<span class="lineno">  194 </span>errorInMove' :: (Int, Int) -&gt; (Int, Int) -&gt; [(Int, Int)] -&gt; Int -&gt; Bool
<span class="lineno">  195 </span><span class="decl"><span class="istickedoff">errorInMove' _ _ [] _ = <span class="nottickedoff">True</span></span>
<span class="lineno">  196 </span><span class="spaces"></span><span class="istickedoff">errorInMove' (start1, start2) (end1, end2) ((x1, x2):xs) turn</span>
<span class="lineno">  197 </span><span class="spaces">    </span><span class="istickedoff">| (end1 &lt; 0) || (end2 &lt; 0) || (end1 &gt; 4) || (end2 &gt; 4) = True</span>
<span class="lineno">  198 </span><span class="spaces">    </span><span class="istickedoff">| (turn == 0) &amp;&amp; (start1 + x1 == end1) &amp;&amp; (start2 + x2 == end2) = False</span>
<span class="lineno">  199 </span><span class="spaces">    </span><span class="istickedoff">| (turn == 1) &amp;&amp; (start1 - x1 == end1) &amp;&amp; (start2 - x2 == end2) = False</span>
<span class="lineno">  200 </span><span class="spaces">    </span><span class="istickedoff">| <span class="tickonlytrue">otherwise</span> = errorInMove' (start1, start2) (end1, end2) xs turn</span></span>
<span class="lineno">  201 </span>
<span class="lineno">  202 </span>-- Gets legal moves associated with the cards in the game
<span class="lineno">  203 </span>-- empty list, if the String is not a card in the game
<span class="lineno">  204 </span>getLegalMoves :: String -&gt; [(Int, Int)]
<span class="lineno">  205 </span><span class="decl"><span class="istickedoff">getLegalMoves card</span>
<span class="lineno">  206 </span><span class="spaces">    </span><span class="istickedoff">| card == &quot;Rabbit&quot;   = [(-1,-1), (1,1), (0,2)]</span>
<span class="lineno">  207 </span><span class="spaces">    </span><span class="istickedoff">| card == &quot;Cobra&quot;    = [(0,-1), (-1,1), (1,1)]</span>
<span class="lineno">  208 </span><span class="spaces">    </span><span class="istickedoff">| card == &quot;Rooster&quot;  = [(-1,-1), (0,-1), (0,1), (1,1)]</span>
<span class="lineno">  209 </span><span class="spaces">    </span><span class="istickedoff">| card == &quot;Tiger&quot;    = [(-1,0), (2, 0)]</span>
<span class="lineno">  210 </span><span class="spaces">    </span><span class="istickedoff">| card == &quot;Monkey&quot;   = [(-1,-1), (-1,1), (1,-1), (1,1)]</span>
<span class="lineno">  211 </span><span class="spaces">    </span><span class="istickedoff">| card == &quot;Crab&quot;     = [(0,-2), (1,0), (0,2)]</span>
<span class="lineno">  212 </span><span class="spaces">    </span><span class="istickedoff">| card == &quot;Crane&quot;    = [(-1,-1), (1,0), (-1,1)]</span>
<span class="lineno">  213 </span><span class="spaces">    </span><span class="istickedoff">| card == &quot;Frog&quot;     = [(0,-2), (1,-1), (-1,1)]</span>
<span class="lineno">  214 </span><span class="spaces">    </span><span class="istickedoff">| card == &quot;Boar&quot;     = [(0,-1), (0,1), (1,0)]</span>
<span class="lineno">  215 </span><span class="spaces">    </span><span class="istickedoff">| card == &quot;Horse&quot;    = [(-1,0), (0,-1), (1,0)]</span>
<span class="lineno">  216 </span><span class="spaces">    </span><span class="istickedoff">| card == &quot;Elephant&quot; = [(1,-1), (0,-1), (0,1), (1,1)]</span>
<span class="lineno">  217 </span><span class="spaces">    </span><span class="istickedoff">| card == &quot;Ox&quot;       = [(0,1), (-1,0), (1,0)]</span>
<span class="lineno">  218 </span><span class="spaces">    </span><span class="istickedoff">| card == &quot;Goose&quot;    = [(-1,1), (0,-1), (0,1), (1,-1)]</span>
<span class="lineno">  219 </span><span class="spaces">    </span><span class="istickedoff">| card == &quot;Dragon&quot;   = [(1,-2), (-1,-1), (-1,1), (1,2)]</span>
<span class="lineno">  220 </span><span class="spaces">    </span><span class="istickedoff">| card == &quot;Mantis&quot;   = [(1,-1), (-1,0), (1,1)]</span>
<span class="lineno">  221 </span><span class="spaces">    </span><span class="istickedoff">| card == &quot;Eel&quot;      = [(1,-1), (-1,-1), (0,1)]</span>
<span class="lineno">  222 </span><span class="spaces">    </span><span class="istickedoff">| <span class="tickonlytrue">otherwise</span> = []</span></span>
<span class="lineno">  223 </span>
<span class="lineno">  224 </span>-- Gets cards names from a index
<span class="lineno">  225 </span>-- empty string, if the index is not described  
<span class="lineno">  226 </span>getCardNames :: Int -&gt; String
<span class="lineno">  227 </span><span class="decl"><span class="istickedoff">getCardNames index</span>
<span class="lineno">  228 </span><span class="spaces">    </span><span class="istickedoff">| index == 0  = &quot;Rabbit&quot; </span>
<span class="lineno">  229 </span><span class="spaces">    </span><span class="istickedoff">| index == 1  = &quot;Cobra&quot; </span>
<span class="lineno">  230 </span><span class="spaces">    </span><span class="istickedoff">| index == 2  = &quot;Rooster&quot;</span>
<span class="lineno">  231 </span><span class="spaces">    </span><span class="istickedoff">| index == 3  = &quot;Tiger&quot; </span>
<span class="lineno">  232 </span><span class="spaces">    </span><span class="istickedoff">| index == 4  = &quot;Monkey&quot; </span>
<span class="lineno">  233 </span><span class="spaces">    </span><span class="istickedoff">| index == 5  = &quot;Crab&quot; </span>
<span class="lineno">  234 </span><span class="spaces">    </span><span class="istickedoff">| index == 6  = &quot;Crane&quot; </span>
<span class="lineno">  235 </span><span class="spaces">    </span><span class="istickedoff">| index == 7  = &quot;Frog&quot; </span>
<span class="lineno">  236 </span><span class="spaces">    </span><span class="istickedoff">| index == 8  = &quot;Boar&quot; </span>
<span class="lineno">  237 </span><span class="spaces">    </span><span class="istickedoff">| index == 9  = &quot;Horse&quot; </span>
<span class="lineno">  238 </span><span class="spaces">    </span><span class="istickedoff">| index == 10 = &quot;Elephant&quot; </span>
<span class="lineno">  239 </span><span class="spaces">    </span><span class="istickedoff">| index == 11 = &quot;Ox&quot; </span>
<span class="lineno">  240 </span><span class="spaces">    </span><span class="istickedoff">| index == 12 = &quot;Goose&quot; </span>
<span class="lineno">  241 </span><span class="spaces">    </span><span class="istickedoff">| index == 13 = &quot;Dragon&quot; </span>
<span class="lineno">  242 </span><span class="spaces">    </span><span class="istickedoff">| index == 14 = &quot;Mantis&quot; </span>
<span class="lineno">  243 </span><span class="spaces">    </span><span class="istickedoff">| <span class="tickonlytrue">index == 15</span> = &quot;Eel&quot;</span></span> 
<span class="lineno">  244 </span>
<span class="lineno">  245 </span>generateRandom :: Int -&gt; Int -&gt; IO (String)
<span class="lineno">  246 </span><span class="decl"><span class="istickedoff">generateRandom seed n = do</span>
<span class="lineno">  247 </span><span class="spaces">    </span><span class="istickedoff">let gen = mkStdGen seed</span>
<span class="lineno">  248 </span><span class="spaces">    </span><span class="istickedoff">let (randomCards, gen1) = getRandomCards gen</span>
<span class="lineno">  249 </span><span class="spaces">    </span><span class="istickedoff">let cards = sortCards [getCardNames card | card &lt;- randomCards]</span>
<span class="lineno">  250 </span><span class="spaces">    </span><span class="istickedoff">let (piecesA, gen2) = getRandomPieces gen1</span>
<span class="lineno">  251 </span><span class="spaces">    </span><span class="istickedoff">let (piecesB, gen3) = getRandomPieces gen2</span>
<span class="lineno">  252 </span><span class="spaces">    </span><span class="istickedoff">let pieces = removeDuplicates piecesA piecesB [] []</span>
<span class="lineno">  253 </span><span class="spaces">    </span><span class="istickedoff">let finalPiecesA = sortPieces (getFirst pieces)</span>
<span class="lineno">  254 </span><span class="spaces">    </span><span class="istickedoff">let finalPiecesB = sortPieces (getSecond pieces)</span>
<span class="lineno">  255 </span><span class="spaces">    </span><span class="istickedoff">let (turn, gen4) = randomR (0,1) gen3</span>
<span class="lineno">  256 </span><span class="spaces">    </span><span class="istickedoff">let state = (State (cards, finalPiecesA, finalPiecesB, turn))</span>
<span class="lineno">  257 </span><span class="spaces">    </span><span class="istickedoff">let moveList = getMovesList state gen4 n</span>
<span class="lineno">  258 </span><span class="spaces">    </span><span class="istickedoff">return (makeOutputString state moveList)</span></span>
<span class="lineno">  259 </span>        
<span class="lineno">  260 </span>-- Returns 5 Int values [0 - 15] with no duplicates
<span class="lineno">  261 </span>getRandomCards :: StdGen -&gt; ([Int], StdGen)
<span class="lineno">  262 </span><span class="decl"><span class="istickedoff">getRandomCards gen = getRandomCards' gen []</span></span>
<span class="lineno">  263 </span>getRandomCards' :: StdGen -&gt; [Int] -&gt; ([Int], StdGen)
<span class="lineno">  264 </span><span class="decl"><span class="istickedoff">getRandomCards' gen foundCards</span>
<span class="lineno">  265 </span><span class="spaces">    </span><span class="istickedoff">| (length foundCards) == 5 = (foundCards, newGen)</span>
<span class="lineno">  266 </span><span class="spaces">    </span><span class="istickedoff">| newCard `elem` foundCards = getRandomCards' newGen foundCards</span>
<span class="lineno">  267 </span><span class="spaces">    </span><span class="istickedoff">| <span class="tickonlytrue">otherwise</span> = getRandomCards' newGen (newCard:foundCards)</span>
<span class="lineno">  268 </span><span class="spaces">    </span><span class="istickedoff">where</span>
<span class="lineno">  269 </span><span class="spaces">        </span><span class="istickedoff">(newCard, newGen) = randomR (0,15) gen</span></span>
<span class="lineno">  270 </span>
<span class="lineno">  271 </span>-- Returns 5 random (Int, Int)
<span class="lineno">  272 </span>getRandomPieces :: StdGen -&gt; ([(Int, Int)], StdGen)
<span class="lineno">  273 </span><span class="decl"><span class="istickedoff">getRandomPieces gen = getRandomPieces' gen []</span></span>
<span class="lineno">  274 </span>getRandomPieces' :: StdGen -&gt; [(Int,Int)] -&gt; ([(Int, Int)], StdGen)
<span class="lineno">  275 </span><span class="decl"><span class="istickedoff">getRandomPieces' gen foundPieces</span>
<span class="lineno">  276 </span><span class="spaces">    </span><span class="istickedoff">| (length foundPieces) == 5 = (foundPieces, newGen2)</span>
<span class="lineno">  277 </span><span class="spaces">    </span><span class="istickedoff">| newPiece `elem` foundPieces = getRandomPieces' newGen2 foundPieces</span>
<span class="lineno">  278 </span><span class="spaces">    </span><span class="istickedoff">| <span class="tickonlytrue">otherwise</span> = getRandomPieces' newGen2 (newPiece:foundPieces)</span>
<span class="lineno">  279 </span><span class="spaces">    </span><span class="istickedoff">where</span>
<span class="lineno">  280 </span><span class="spaces">        </span><span class="istickedoff">(newPiece0, newGen1) = randomR (0,4) gen</span>
<span class="lineno">  281 </span><span class="spaces">        </span><span class="istickedoff">(newPiece1, newGen2) = randomR (0,4) newGen1</span>
<span class="lineno">  282 </span><span class="spaces">        </span><span class="istickedoff">newPiece = (newPiece0, newPiece1)</span></span>
<span class="lineno">  283 </span>
<span class="lineno">  284 </span>-- Removes pieces that are standing on the same tile
<span class="lineno">  285 </span>removeDuplicates :: [(Int, Int)] -&gt; [(Int, Int)] -&gt; [(Int, Int)] -&gt; [(Int, Int)] -&gt; ([(Int, Int)], [(Int, Int)])
<span class="lineno">  286 </span><span class="decl"><span class="istickedoff">removeDuplicates [] _ acceptedPiecesA acceptedPiecesB = (acceptedPiecesA, acceptedPiecesB)</span>
<span class="lineno">  287 </span><span class="spaces"></span><span class="istickedoff">removeDuplicates piecesA piecesB acceptedPiecesA acceptedPiecesB</span>
<span class="lineno">  288 </span><span class="spaces">    </span><span class="istickedoff">| x `elem` (y:ys) = removeDuplicates xs ys acceptedPiecesA (y:acceptedPiecesB)</span>
<span class="lineno">  289 </span><span class="spaces">    </span><span class="istickedoff">| y `elem` (x:xs) = removeDuplicates xs ys (x:acceptedPiecesA) acceptedPiecesB</span>
<span class="lineno">  290 </span><span class="spaces">    </span><span class="istickedoff">| <span class="tickonlytrue">otherwise</span> = removeDuplicates xs ys (x:acceptedPiecesA) (y:acceptedPiecesB)</span>
<span class="lineno">  291 </span><span class="spaces">    </span><span class="istickedoff">where</span>
<span class="lineno">  292 </span><span class="spaces">        </span><span class="istickedoff">(x:xs) = piecesA</span>
<span class="lineno">  293 </span><span class="spaces">        </span><span class="istickedoff">(y:ys) = piecesB</span></span>
<span class="lineno">  294 </span>
<span class="lineno">  295 </span>-- Turns State and [Move] into a formatted string, seperated with \n
<span class="lineno">  296 </span>makeOutputString :: State -&gt; [Move] -&gt; String
<span class="lineno">  297 </span><span class="decl"><span class="istickedoff">makeOutputString state moves = makeOutputString' state moves &quot;&quot;</span></span>
<span class="lineno">  298 </span><span class="decl"><span class="istickedoff">makeOutputString' state [] output = (removeFirstWord (show state)) ++ &quot;\n&quot; ++ output</span>
<span class="lineno">  299 </span><span class="spaces"></span><span class="istickedoff">makeOutputString' state (move:moves) output</span>
<span class="lineno">  300 </span><span class="spaces">    </span><span class="istickedoff">= makeOutputString' state moves (output ++ (removeFirstWord (show move)) ++ &quot;\n&quot;)</span></span>
<span class="lineno">  301 </span>
<span class="lineno">  302 </span>-- Returns a list of all valid moves from a given state
<span class="lineno">  303 </span>-- Also keeps track of whether a move is a winning move or not
<span class="lineno">  304 </span>allValidMoves :: State -&gt; [(Bool, Move)]
<span class="lineno">  305 </span><span class="decl"><span class="istickedoff">allValidMoves (State (cards, piecesA, piecesB, turn)) = validMoves</span>
<span class="lineno">  306 </span><span class="spaces">    </span><span class="istickedoff">where</span>
<span class="lineno">  307 </span><span class="spaces">        </span><span class="istickedoff">pieces' = if turn == 0 then piecesA else piecesB</span>
<span class="lineno">  308 </span><span class="spaces">        </span><span class="istickedoff"><span class="nottickedoff">cards' = if turn == 0 then (take 2 cards) else ([cards' !! 2] ++ [cards !! 3])</span></span>
<span class="lineno">  309 </span><span class="spaces">        </span><span class="istickedoff">cards'' = [(card, getLegalMoves card) | card &lt;- cards]</span>
<span class="lineno">  310 </span><span class="spaces">        </span><span class="istickedoff">validMoves = </span>
<span class="lineno">  311 </span><span class="spaces">            </span><span class="istickedoff">[</span>
<span class="lineno">  312 </span><span class="spaces">             </span><span class="istickedoff">((winningMove piece card piecesA piecesB turn index),  -- Check if winning move</span>
<span class="lineno">  313 </span><span class="spaces">              </span><span class="istickedoff">Move (piece, (calcMove piece card turn index), (getCardName card))) -- Move containing valid move</span>
<span class="lineno">  314 </span><span class="spaces">              </span><span class="istickedoff">| piece &lt;- pieces', -- Get a piece</span>
<span class="lineno">  315 </span><span class="spaces">                </span><span class="istickedoff">card &lt;- cards'',  -- Get a (cardString, cardMove) tuple</span>
<span class="lineno">  316 </span><span class="spaces">                </span><span class="istickedoff">index &lt;- [0..((length (cardMoves card))-1)], -- List of 0 to length of number of moves-1 from card</span>
<span class="lineno">  317 </span><span class="spaces">                </span><span class="istickedoff">(not (errorInMove cards (Move (piece, (calcMove piece card turn index), (getCardName card))) piecesA piecesB turn)) -- Only add move to list if it is valid)</span>
<span class="lineno">  318 </span><span class="spaces">            </span><span class="istickedoff">]</span></span> 
<span class="lineno">  319 </span>
<span class="lineno">  320 </span>-- Returns true if provided information gives a winning move
<span class="lineno">  321 </span>winningMove :: (Int, Int) -&gt; (String, [(Int, Int)]) -&gt; [(Int, Int)] -&gt; [(Int, Int)] -&gt; Int -&gt; Int -&gt; Bool
<span class="lineno">  322 </span><span class="decl"><span class="istickedoff">winningMove piece card piecesA piecesB turn index</span>
<span class="lineno">  323 </span><span class="spaces">    </span><span class="istickedoff">| turn == 0 &amp;&amp; (piece == head piecesA) &amp;&amp; ((calcMove piece card turn index) == (4,2)) = True</span>
<span class="lineno">  324 </span><span class="spaces">    </span><span class="istickedoff">| turn == 1 &amp;&amp; (piece == head piecesB) &amp;&amp; ((calcMove piece card turn index) == (0,2)) = True</span>
<span class="lineno">  325 </span><span class="spaces">    </span><span class="istickedoff">| turn == 0 &amp;&amp; ((calcMove piece card turn index) == (head piecesB)) = True</span>
<span class="lineno">  326 </span><span class="spaces">    </span><span class="istickedoff">| turn == 1 &amp;&amp; ((calcMove piece card turn index) == (head piecesA)) = True</span>
<span class="lineno">  327 </span><span class="spaces">    </span><span class="istickedoff">| <span class="tickonlytrue">otherwise</span> = False</span></span>
<span class="lineno">  328 </span>
<span class="lineno">  329 </span>-- A description has been written over the parameters:
<span class="lineno">  330 </span>--             piece        entry of cards''     turn
<span class="lineno">  331 </span>calcMove :: (Int, Int) -&gt; (String, [(Int, Int)]) -&gt; Int -&gt; Int -&gt; (Int, Int)
<span class="lineno">  332 </span><span class="decl"><span class="istickedoff">calcMove (start0, start1) card turn index</span>
<span class="lineno">  333 </span><span class="spaces">    </span><span class="istickedoff">| turn == 0 = ((start0+cardMove0), (start1+cardMove1))</span>
<span class="lineno">  334 </span><span class="spaces">    </span><span class="istickedoff">| <span class="tickonlytrue">turn == 1</span> = ((start0-cardMove0), (start1-cardMove1))</span>
<span class="lineno">  335 </span><span class="spaces">    </span><span class="istickedoff">where</span>
<span class="lineno">  336 </span><span class="spaces">        </span><span class="istickedoff">moves = cardMoves card</span>
<span class="lineno">  337 </span><span class="spaces">        </span><span class="istickedoff">(cardMove0, cardMove1) = (moves !! index)</span></span>
<span class="lineno">  338 </span>
<span class="lineno">  339 </span>-- Extract name of card from (cardName, cardMove) tuple
<span class="lineno">  340 </span>getCardName :: (String, [(Int, Int)]) -&gt; String
<span class="lineno">  341 </span><span class="decl"><span class="istickedoff">getCardName (string, cardMoves) = string</span></span>
<span class="lineno">  342 </span>
<span class="lineno">  343 </span>-- Gets all moves from a card
<span class="lineno">  344 </span>cardMoves :: (String, [(Int, Int)]) -&gt; [(Int, Int)]
<span class="lineno">  345 </span><span class="decl"><span class="istickedoff">cardMoves (string, cardMovesList) = cardMovesList</span></span>
<span class="lineno">  346 </span>
<span class="lineno">  347 </span>-- Makes a pseudorandom list of moves
<span class="lineno">  348 </span>getMovesList :: State -&gt; StdGen -&gt; Int -&gt; [Move]
<span class="lineno">  349 </span><span class="decl"><span class="istickedoff">getMovesList state gen n</span>
<span class="lineno">  350 </span><span class="spaces">    </span><span class="istickedoff">= getMovesList' state gen n []</span></span>
<span class="lineno">  351 </span>getMovesList' :: State -&gt; StdGen -&gt; Int -&gt; [Move] -&gt; [Move]
<span class="lineno">  352 </span><span class="decl"><span class="istickedoff">getMovesList' state gen n foundMoves</span>
<span class="lineno">  353 </span><span class="spaces">    </span><span class="istickedoff">| (length foundMoves) == n = foundMoves</span>
<span class="lineno">  354 </span><span class="spaces">    </span><span class="istickedoff">| null validMoves = foundMoves</span>
<span class="lineno">  355 </span><span class="spaces">    </span><span class="istickedoff">| winningMove = (foundMoves++[randomMove])</span>
<span class="lineno">  356 </span><span class="spaces">    </span><span class="istickedoff">| <span class="tickonlytrue">otherwise</span> = getMovesList' newState newGen n (foundMoves++[randomMove]) </span>
<span class="lineno">  357 </span><span class="spaces">    </span><span class="istickedoff">where</span>
<span class="lineno">  358 </span><span class="spaces">        </span><span class="istickedoff">validMoves = allValidMoves state</span>
<span class="lineno">  359 </span><span class="spaces">        </span><span class="istickedoff">nMoves = length validMoves</span>
<span class="lineno">  360 </span><span class="spaces">        </span><span class="istickedoff">(randomIndex, newGen) = randomR (0, (nMoves-1)) gen</span>
<span class="lineno">  361 </span><span class="spaces">        </span><span class="istickedoff">randomMoveTuple = (validMoves !! randomIndex)</span>
<span class="lineno">  362 </span><span class="spaces">        </span><span class="istickedoff">randomMove = extractMove randomMoveTuple</span>
<span class="lineno">  363 </span><span class="spaces">        </span><span class="istickedoff">winningMove = extractWinning randomMoveTuple</span>
<span class="lineno">  364 </span><span class="spaces">        </span><span class="istickedoff">newState = (applyMove state randomMove)</span></span>
<span class="lineno">  365 </span>
<span class="lineno">  366 </span>-- Extracts move from (Bool, Move) tuple
<span class="lineno">  367 </span>extractMove :: (Bool, Move) -&gt; Move
<span class="lineno">  368 </span><span class="decl"><span class="istickedoff">extractMove (bool, move) = move</span></span>
<span class="lineno">  369 </span>
<span class="lineno">  370 </span>-- Extracts winning bool from (Bool, Move) tuple
<span class="lineno">  371 </span>extractWinning :: (Bool, Move) -&gt; Bool
<span class="lineno">  372 </span><span class="decl"><span class="istickedoff">extractWinning (bool, move) = bool</span></span>
<span class="lineno">  373 </span>
<span class="lineno">  374 </span>movesNumbers :: Int -&gt; String -&gt; IO (String)
<span class="lineno">  375 </span><span class="decl"><span class="istickedoff">movesNumbers n filePath = do</span>
<span class="lineno">  376 </span><span class="spaces">    </span><span class="istickedoff">contents &lt;- readFile filePath</span>
<span class="lineno">  377 </span><span class="spaces">    </span><span class="istickedoff">let linesAsList = lines contents</span>
<span class="lineno">  378 </span><span class="spaces">    </span><span class="istickedoff">let state = (&quot;State &quot; ++ (head linesAsList))</span>
<span class="lineno">  379 </span><span class="spaces">    </span><span class="istickedoff">let maybeState = readMaybe state :: Maybe State</span>
<span class="lineno">  380 </span><span class="spaces">    </span><span class="istickedoff">-- Getting maybe state</span>
<span class="lineno">  381 </span><span class="spaces">    </span><span class="istickedoff">if <span class="tickonlyfalse">(isNothing maybeState)</span></span>
<span class="lineno">  382 </span><span class="spaces">    </span><span class="istickedoff">then <span class="nottickedoff">return (show (&quot;ParsingError&quot;, -1, -1, -1) )</span></span>
<span class="lineno">  383 </span><span class="spaces">    </span><span class="istickedoff">-- Checking for empty moves list or invalid state</span>
<span class="lineno">  384 </span><span class="spaces">    </span><span class="istickedoff">else if <span class="tickonlyfalse">(errorInState (read state :: State) /= 0)</span></span>
<span class="lineno">  385 </span><span class="spaces">    </span><span class="istickedoff">then <span class="nottickedoff">return (show (&quot;ParsingError&quot;, -1, -1, -1))</span></span>
<span class="lineno">  386 </span><span class="spaces">    </span><span class="istickedoff">else return (show (movesNumberResult n (read state :: State)))</span></span>
<span class="lineno">  387 </span>
<span class="lineno">  388 </span>movesNumberResult :: Int -&gt; State -&gt; (String, Int, Int, Int)
<span class="lineno">  389 </span><span class="decl"><span class="istickedoff">movesNumberResult n state@(State (cards, piecesA, piecesB, turn))</span>
<span class="lineno">  390 </span><span class="spaces">    </span><span class="istickedoff">| <span class="tickonlyfalse">n == 0</span> = <span class="nottickedoff">(&quot;OK&quot;, 0, 0, 0)</span></span>
<span class="lineno">  391 </span><span class="spaces">    </span><span class="istickedoff">| <span class="tickonlytrue">otherwise</span> = result</span>
<span class="lineno">  392 </span><span class="spaces">    </span><span class="istickedoff">where</span>
<span class="lineno">  393 </span><span class="spaces">        </span><span class="istickedoff">startingPlayer = turn</span>
<span class="lineno">  394 </span><span class="spaces">        </span><span class="istickedoff">(lastStates, (winning, losing)) = findAllStates n state</span>
<span class="lineno">  395 </span><span class="spaces">        </span><span class="istickedoff">lastSequences = [(sequencesFromState aState startingPlayer) | aState &lt;- lastStates]</span>
<span class="lineno">  396 </span><span class="spaces">        </span><span class="istickedoff">(lastTotal, lastWinning, lastLosing) = addUpSequences lastSequences</span>
<span class="lineno">  397 </span><span class="spaces">        </span><span class="istickedoff">(total', winning', losing') = </span>
<span class="lineno">  398 </span><span class="spaces">            </span><span class="istickedoff">if <span class="tickonlytrue">n `mod` 2 == 1</span></span>
<span class="lineno">  399 </span><span class="spaces">            </span><span class="istickedoff">then ((lastTotal+(winning+losing)), (lastWinning+winning), (lastLosing+losing))</span>
<span class="lineno">  400 </span><span class="spaces">            </span><span class="istickedoff">else <span class="nottickedoff">((lastTotal+(winning+losing)), (lastWinning+losing), (lastLosing+winning))</span></span>
<span class="lineno">  401 </span><span class="spaces">        </span><span class="istickedoff">result = (&quot;OK&quot;, total', winning', losing')</span></span>
<span class="lineno">  402 </span>
<span class="lineno">  403 </span>findAllStates :: Int -&gt; State -&gt; ([State], (Int, Int))
<span class="lineno">  404 </span><span class="decl"><span class="istickedoff">findAllStates n state = findAllStates' n ([state], (0,0))</span></span>
<span class="lineno">  405 </span>findAllStates' :: Int -&gt; ([State], (Int, Int)) -&gt; ([State], (Int, Int))
<span class="lineno">  406 </span><span class="decl"><span class="istickedoff">findAllStates' n (foundStates, winningCount)</span>
<span class="lineno">  407 </span><span class="spaces">    </span><span class="istickedoff">| <span class="tickonlytrue">n == 1</span> = (foundStates, winningCount)</span>
<span class="lineno">  408 </span><span class="spaces">    </span><span class="istickedoff">| <span class="nottickedoff">otherwise</span> = </span>
<span class="lineno">  409 </span><span class="spaces">        </span><span class="istickedoff"><span class="nottickedoff">findAllStates' (n-1) ([</span></span>
<span class="lineno">  410 </span><span class="spaces">                              </span><span class="istickedoff"><span class="nottickedoff">applyMove state (extractMove move)</span></span>
<span class="lineno">  411 </span><span class="spaces">                              </span><span class="istickedoff"><span class="nottickedoff">| state &lt;- foundStates,</span></span>
<span class="lineno">  412 </span><span class="spaces">                                </span><span class="istickedoff"><span class="nottickedoff">move &lt;- allValidMoves state</span></span>
<span class="lineno">  413 </span><span class="spaces">                              </span><span class="istickedoff"><span class="nottickedoff">], newWinningCount)</span></span>
<span class="lineno">  414 </span><span class="spaces">    </span><span class="istickedoff">where</span>
<span class="lineno">  415 </span><span class="spaces">        </span><span class="istickedoff">(player0, player1) = <span class="nottickedoff">winningCount</span></span>
<span class="lineno">  416 </span><span class="spaces">        </span><span class="istickedoff"><span class="nottickedoff">winningResult = player0 + (sum [1 | state &lt;- foundStates, move &lt;- allValidMoves state, (extractWinning move)])</span></span>
<span class="lineno">  417 </span><span class="spaces">        </span><span class="istickedoff"><span class="nottickedoff">newWinningCount = (player1, winningResult)</span></span></span>
<span class="lineno">  418 </span>        
<span class="lineno">  419 </span>
<span class="lineno">  420 </span>sequencesFromState :: State -&gt; Int -&gt; (Int, Int, Int)
<span class="lineno">  421 </span><span class="decl"><span class="istickedoff">sequencesFromState state@(State (cards, piecesA, piecesB, turn)) startingPlayer = (total, winning, losing)</span>
<span class="lineno">  422 </span><span class="spaces">    </span><span class="istickedoff">where</span>
<span class="lineno">  423 </span><span class="spaces">        </span><span class="istickedoff">allMovesFromState = allValidMoves state</span>
<span class="lineno">  424 </span><span class="spaces">        </span><span class="istickedoff">total = length allMovesFromState</span>
<span class="lineno">  425 </span><span class="spaces">        </span><span class="istickedoff">winning = if <span class="tickonlytrue">(turn == startingPlayer)</span> then sum [<span class="nottickedoff">1</span> | move &lt;- allMovesFromState, <span class="tickonlyfalse">extractWinning move</span>] else <span class="nottickedoff">0</span></span>
<span class="lineno">  426 </span><span class="spaces">        </span><span class="istickedoff">losing  = if <span class="tickonlyfalse">(turn /= startingPlayer)</span> then <span class="nottickedoff">sum [1 | move &lt;- allMovesFromState, extractWinning move]</span> else 0</span></span>
<span class="lineno">  427 </span>
<span class="lineno">  428 </span>-- Function names says it all 
<span class="lineno">  429 </span>addUpSequences :: [(Int, Int, Int)] -&gt; (Int, Int, Int)
<span class="lineno">  430 </span><span class="decl"><span class="istickedoff">addUpSequences allSequences = addUpSequences' allSequences initialResult</span>
<span class="lineno">  431 </span><span class="spaces">    </span><span class="istickedoff">where</span>
<span class="lineno">  432 </span><span class="spaces">        </span><span class="istickedoff">initialResult = (0, 0, 0)</span></span>
<span class="lineno">  433 </span>addUpSequences' :: [(Int, Int, Int)] -&gt; (Int, Int, Int) -&gt; (Int, Int, Int)
<span class="lineno">  434 </span><span class="decl"><span class="istickedoff">addUpSequences' allSequences resultCount</span>
<span class="lineno">  435 </span><span class="spaces">    </span><span class="istickedoff">| null allSequences = resultCount</span>
<span class="lineno">  436 </span><span class="spaces">    </span><span class="istickedoff">| <span class="tickonlytrue">otherwise</span> = addUpSequences' seqs intermediateResult</span>
<span class="lineno">  437 </span><span class="spaces">    </span><span class="istickedoff">where</span>
<span class="lineno">  438 </span><span class="spaces">        </span><span class="istickedoff">(seq:seqs) = allSequences</span>
<span class="lineno">  439 </span><span class="spaces">        </span><span class="istickedoff">(seqTotal, seqWinning, seqLosing) = seq</span>
<span class="lineno">  440 </span><span class="spaces">        </span><span class="istickedoff">(resTotal, resWinning, resLosing) = resultCount</span>
<span class="lineno">  441 </span><span class="spaces">        </span><span class="istickedoff">intermediateResult = ((resTotal+seqTotal), (resWinning+seqWinning), (resLosing+seqLosing))</span></span>

</pre>
</body>
</html>
