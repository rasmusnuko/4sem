<html>
<head>
<meta http-equiv="Content-Type" content="text/html; charset=CP850">
<style type="text/css">
span.lineno { color: white; background: #aaaaaa; border-right: solid white 12px }
span.nottickedoff { background: yellow}
span.istickedoff { background: white }
span.tickonlyfalse { margin: -1px; border: 1px solid #f20913; background: #f20913 }
span.tickonlytrue  { margin: -1px; border: 1px solid #60de51; background: #60de51 }
span.funcount { font-size: small; color: orange; z-index: 2; position: absolute; right: 20 }
span.decl { font-weight: bold }
span.spaces    { background: white }
</style>
</head>
<body>
<pre>
<span class="decl"><span class="nottickedoff">never executed</span> <span class="tickonlytrue">always true</span> <span class="tickonlyfalse">always false</span></span>
</pre>
<pre>
<span class="lineno">    1 </span>module Lib (
<span class="lineno">    2 </span> generateRandom,
<span class="lineno">    3 </span> isValid,
<span class="lineno">    4 </span> movesNumbers,
<span class="lineno">    5 </span> isValidAux
<span class="lineno">    6 </span>) where
<span class="lineno">    7 </span>
<span class="lineno">    8 </span>import System.IO
<span class="lineno">    9 </span>import Control.Monad
<span class="lineno">   10 </span>import System.Random
<span class="lineno">   11 </span>import Data.Maybe
<span class="lineno">   12 </span>import Data.List
<span class="lineno">   13 </span>import Text.Read
<span class="lineno">   14 </span>
<span class="lineno">   15 </span>data State = State ([String], [(Int, Int)], [(Int, Int)], Int) deriving (<span class="decl"><span class="istickedoff">Show</span></span>, <span class="decl"><span class="nottickedoff"><span class="decl"><span class="istickedoff"><span class="decl"><span class="nottickedoff">Read</span></span></span></span></span></span>)
<span class="lineno">   16 </span>data Move = Move ((Int, Int), (Int,Int), String) deriving (<span class="decl"><span class="istickedoff">Show</span></span>, <span class="decl"><span class="nottickedoff"><span class="decl"><span class="istickedoff"><span class="decl"><span class="nottickedoff">Read</span></span></span></span></span></span>)
<span class="lineno">   17 </span>
<span class="lineno">   18 </span>-- Parses State and [Moves] from a filePath
<span class="lineno">   19 </span>-- and passes the data to isValidAux
<span class="lineno">   20 </span>isValid :: String -&gt; IO (String)
<span class="lineno">   21 </span><span class="decl"><span class="istickedoff">isValid filePath = do</span>
<span class="lineno">   22 </span><span class="spaces">    </span><span class="istickedoff">contents &lt;- readFile filePath</span>
<span class="lineno">   23 </span><span class="spaces">    </span><span class="istickedoff">let linesAsList = lines contents</span>
<span class="lineno">   24 </span><span class="spaces">    </span><span class="istickedoff">let state = (&quot;State &quot; ++ (head linesAsList))</span>
<span class="lineno">   25 </span><span class="spaces">    </span><span class="istickedoff">let moves = [&quot;Move &quot; ++ x | x &lt;- (tail linesAsList)]</span>
<span class="lineno">   26 </span><span class="spaces">    </span><span class="istickedoff">let maybeState = readMaybe state :: Maybe State</span>
<span class="lineno">   27 </span><span class="spaces">    </span><span class="istickedoff">let maybeMoves = [readMaybe x :: Maybe Move | x &lt;- moves]</span>
<span class="lineno">   28 </span><span class="spaces">    </span><span class="istickedoff">-- Getting maybe state</span>
<span class="lineno">   29 </span><span class="spaces">    </span><span class="istickedoff">if (isNothing maybeState)</span>
<span class="lineno">   30 </span><span class="spaces">    </span><span class="istickedoff">then return &quot;ParsingError&quot;</span>
<span class="lineno">   31 </span><span class="spaces">    </span><span class="istickedoff">-- Getting maybe moves</span>
<span class="lineno">   32 </span><span class="spaces">    </span><span class="istickedoff">else if <span class="tickonlyfalse">any (&amp;&amp;<span class="nottickedoff">True</span>) [isNothing x | x &lt;- maybeMoves]</span></span>
<span class="lineno">   33 </span><span class="spaces">    </span><span class="istickedoff">then <span class="nottickedoff">return &quot;ParsingError&quot;</span></span>
<span class="lineno">   34 </span><span class="spaces">    </span><span class="istickedoff">-- Checking for empty moves list or invalid state</span>
<span class="lineno">   35 </span><span class="spaces">    </span><span class="istickedoff">else if (null maybeMoves)</span>
<span class="lineno">   36 </span><span class="spaces">    </span><span class="istickedoff">then return &quot;ParsingError&quot;</span>
<span class="lineno">   37 </span><span class="spaces">    </span><span class="istickedoff">else if (errorInState (read state :: State) /= 0)</span>
<span class="lineno">   38 </span><span class="spaces">    </span><span class="istickedoff">then return &quot;ParsingError&quot;</span>
<span class="lineno">   39 </span><span class="spaces">    </span><span class="istickedoff">else return (isValidAux (read state :: State) [ read x :: Move | x &lt;- moves])</span></span> 
<span class="lineno">   40 </span>
<span class="lineno">   41 </span>-- Passes the State and list of Move's on to isValidAux',
<span class="lineno">   42 </span>-- along side a counter used to keep track of the amount of moves played
<span class="lineno">   43 </span>isValidAux :: State -&gt; [Move] -&gt; [Char]
<span class="lineno">   44 </span><span class="decl"><span class="istickedoff">isValidAux state [] = removeFirstWord (show state)</span>
<span class="lineno">   45 </span><span class="spaces"></span><span class="istickedoff">isValidAux (State (cards, piecesA, piecesB, turn)) (move:moves) </span>
<span class="lineno">   46 </span><span class="spaces">    </span><span class="istickedoff">| <span class="tickonlyfalse">(null piecesA || null piecesB) &amp;&amp; <span class="nottickedoff">not (null (move:moves))</span></span> = <span class="nottickedoff">&quot;NonValid &quot; ++ removeFirstWord (show move)</span></span>
<span class="lineno">   47 </span><span class="spaces">    </span><span class="istickedoff">| errorInMove cards move piecesA piecesB turn = &quot;NonValid &quot; ++ removeFirstWord (show move)</span>
<span class="lineno">   48 </span><span class="spaces">    </span><span class="istickedoff">| <span class="tickonlyfalse">errorInState newState /= 0</span> = <span class="nottickedoff">&quot;NonValid &quot; ++ removeFirstWord (show move)</span></span>
<span class="lineno">   49 </span><span class="spaces">    </span><span class="istickedoff">| <span class="tickonlytrue">otherwise</span> = isValidAux newState moves</span>
<span class="lineno">   50 </span><span class="spaces">    </span><span class="istickedoff">where</span>
<span class="lineno">   51 </span><span class="spaces">        </span><span class="istickedoff"><span class="nottickedoff">state = (State (cards, piecesA, piecesB, turn))</span></span>
<span class="lineno">   52 </span><span class="spaces">        </span><span class="istickedoff">newState = applyMove (State (cards, piecesA, piecesB, turn)) move</span></span> 
<span class="lineno">   53 </span>
<span class="lineno">   54 </span>-- Removes everything up to and including the first space
<span class="lineno">   55 </span>removeFirstWord :: [Char] -&gt; String 
<span class="lineno">   56 </span><span class="decl"><span class="istickedoff">removeFirstWord [] = <span class="nottickedoff">[]</span></span>
<span class="lineno">   57 </span><span class="spaces"></span><span class="istickedoff">removeFirstWord (x:xs)</span>
<span class="lineno">   58 </span><span class="spaces">    </span><span class="istickedoff">| (x == ' ') = xs</span>
<span class="lineno">   59 </span><span class="spaces">    </span><span class="istickedoff">| <span class="tickonlytrue">otherwise</span> = removeFirstWord xs</span></span>
<span class="lineno">   60 </span>
<span class="lineno">   61 </span>-- Takes a State and a Move, and returns a new State where the Move has been performed
<span class="lineno">   62 </span>applyMove :: State -&gt; Move -&gt; State
<span class="lineno">   63 </span><span class="decl"><span class="istickedoff">applyMove (State (cards, piecesA, piecesB, turn)) (Move (start, end, card))</span>
<span class="lineno">   64 </span><span class="spaces">    </span><span class="istickedoff">= (State (cards', piecesA', piecesB', turn'))</span>
<span class="lineno">   65 </span><span class="spaces">    </span><span class="istickedoff">where</span>
<span class="lineno">   66 </span><span class="spaces">        </span><span class="istickedoff">cards' = sortCards (swapCards cards card)</span>
<span class="lineno">   67 </span><span class="spaces">        </span><span class="istickedoff">piecesA' = sortPieces (getFirst (applyPieces start end turn piecesA piecesB))</span>
<span class="lineno">   68 </span><span class="spaces">        </span><span class="istickedoff">piecesB' = sortPieces (getSecond (applyPieces start end turn piecesA piecesB))</span>
<span class="lineno">   69 </span><span class="spaces">        </span><span class="istickedoff">turn' = (if turn == 0 then 1 else 0)</span></span>
<span class="lineno">   70 </span>
<span class="lineno">   71 </span>-- Swaps played card with the last card
<span class="lineno">   72 </span><span class="decl"><span class="istickedoff">swapCards (x:xs) card</span>
<span class="lineno">   73 </span><span class="spaces">    </span><span class="istickedoff">| x == card = (last xs):(swapCards xs card)</span>
<span class="lineno">   74 </span><span class="spaces">    </span><span class="istickedoff">| null xs = card:[]</span>
<span class="lineno">   75 </span><span class="spaces">    </span><span class="istickedoff">| <span class="tickonlytrue">otherwise</span> = x:(swapCards xs card)</span></span>
<span class="lineno">   76 </span>
<span class="lineno">   77 </span>-- Sorts first and second, and third and fourth cards, lexicographically repectively
<span class="lineno">   78 </span>sortCards :: [[Char]] -&gt; [[Char]]
<span class="lineno">   79 </span><span class="decl"><span class="istickedoff">sortCards cards = (sort(take 2 cards)) ++ (sort((cards !! 2):(cards !! 3):[])) ++ (last cards):[]</span></span>
<span class="lineno">   80 </span>
<span class="lineno">   81 </span>-- Checks if any player has won
<span class="lineno">   82 </span>applyPieces :: (Int, Int) -&gt; (Int, Int) -&gt; Int -&gt; [(Int, Int)] -&gt; [(Int, Int)] -&gt; ([(Int, Int)], [(Int, Int)])
<span class="lineno">   83 </span><span class="decl"><span class="istickedoff">applyPieces start end turn piecesA piecesB</span>
<span class="lineno">   84 </span><span class="spaces">    </span><span class="istickedoff">| <span class="tickonlyfalse">turn == 0 &amp;&amp; (head newPiecesA) == (4,<span class="nottickedoff">2</span>)</span>  = <span class="nottickedoff">(newPiecesA, [])</span></span>
<span class="lineno">   85 </span><span class="spaces">    </span><span class="istickedoff">| <span class="tickonlyfalse">turn == 1 &amp;&amp; (head newPiecesB) == (0,<span class="nottickedoff">2</span>)</span> = <span class="nottickedoff">([], newPiecesB)</span></span>
<span class="lineno">   86 </span><span class="spaces">    </span><span class="istickedoff">| turn == 0 &amp;&amp; end == (head newPiecesB) = (newPiecesA, [])</span>
<span class="lineno">   87 </span><span class="spaces">    </span><span class="istickedoff">| turn == 1 &amp;&amp; end == (head newPiecesA) = ([], newPiecesB)</span>
<span class="lineno">   88 </span><span class="spaces">    </span><span class="istickedoff">| turn == 0 &amp;&amp; elem end (tail newPiecesB) = (newPiecesA, (hitDetected piecesB end))</span>
<span class="lineno">   89 </span><span class="spaces">    </span><span class="istickedoff">| <span class="tickonlyfalse">turn == 1 &amp;&amp; elem end (tail newPiecesA)</span> = <span class="nottickedoff">((hitDetected piecesA end), newPiecesB)</span></span>
<span class="lineno">   90 </span><span class="spaces">    </span><span class="istickedoff">| <span class="tickonlytrue">otherwise</span> = (newPiecesA, newPiecesB)</span>
<span class="lineno">   91 </span><span class="spaces">    </span><span class="istickedoff">where  -- Getting the new positions</span>
<span class="lineno">   92 </span><span class="spaces">        </span><span class="istickedoff">newPiecesA = applyPiecesA start end turn piecesA</span>
<span class="lineno">   93 </span><span class="spaces">        </span><span class="istickedoff">newPiecesB = applyPiecesB start end turn piecesB</span></span>
<span class="lineno">   94 </span>
<span class="lineno">   95 </span>-- Sorts a players pieces lexicographically
<span class="lineno">   96 </span>sortPieces :: [(Int, Int)] -&gt; [(Int, Int)]
<span class="lineno">   97 </span><span class="decl"><span class="istickedoff">sortPieces [] = []</span>
<span class="lineno">   98 </span><span class="spaces"></span><span class="istickedoff">sortPieces (x:xs)</span>
<span class="lineno">   99 </span><span class="spaces">    </span><span class="istickedoff">| null xs = [x]</span>
<span class="lineno">  100 </span><span class="spaces">    </span><span class="istickedoff">| <span class="tickonlytrue">otherwise</span> = x:(sort xs)</span></span>
<span class="lineno">  101 </span>
<span class="lineno">  102 </span>-- Updating player A's pieces
<span class="lineno">  103 </span>applyPiecesA :: (Int, Int) -&gt; (Int, Int) -&gt; Int -&gt; [(Int, Int)] -&gt; [(Int, Int)]
<span class="lineno">  104 </span><span class="decl"><span class="istickedoff">applyPiecesA start end turn piecesA</span>
<span class="lineno">  105 </span><span class="spaces">    </span><span class="istickedoff">| turn == 1 = piecesA</span>
<span class="lineno">  106 </span><span class="spaces">    </span><span class="istickedoff">| <span class="tickonlytrue">otherwise</span> = swapPieces piecesA start end</span></span>
<span class="lineno">  107 </span>
<span class="lineno">  108 </span>-- Updating player B's pieces
<span class="lineno">  109 </span>applyPiecesB :: (Int, Int) -&gt; (Int, Int) -&gt; Int -&gt; [(Int, Int)] -&gt; [(Int, Int)]
<span class="lineno">  110 </span><span class="decl"><span class="istickedoff">applyPiecesB start end turn piecesB</span>
<span class="lineno">  111 </span><span class="spaces">    </span><span class="istickedoff">| turn ==  0 = piecesB</span>
<span class="lineno">  112 </span><span class="spaces">    </span><span class="istickedoff">| <span class="tickonlytrue">otherwise</span> = swapPieces piecesB start end</span></span>
<span class="lineno">  113 </span>
<span class="lineno">  114 </span>-- Swaps start with end and returns the new list
<span class="lineno">  115 </span>swapPieces :: [(Int, Int)] -&gt; (Int, Int) -&gt; (Int, Int) -&gt; [(Int, Int)]
<span class="lineno">  116 </span><span class="decl"><span class="istickedoff">swapPieces [] _ _ = []</span>
<span class="lineno">  117 </span><span class="spaces"></span><span class="istickedoff">swapPieces (x:xs) start end</span>
<span class="lineno">  118 </span><span class="spaces">    </span><span class="istickedoff">| x == start = end:(swapPieces xs start <span class="nottickedoff">end</span>)</span>
<span class="lineno">  119 </span><span class="spaces">    </span><span class="istickedoff">| <span class="tickonlytrue">otherwise</span> = x:(swapPieces xs start end)</span></span>
<span class="lineno">  120 </span>
<span class="lineno">  121 </span>-- Removes a piece from a list
<span class="lineno">  122 </span>hitDetected :: [(Int, Int)] -&gt; (Int, Int) -&gt; [(Int, Int)]
<span class="lineno">  123 </span><span class="decl"><span class="istickedoff">hitDetected (x:xs) end</span>
<span class="lineno">  124 </span><span class="spaces">    </span><span class="istickedoff">| null xs = []</span>
<span class="lineno">  125 </span><span class="spaces">    </span><span class="istickedoff">| x == end = (hitDetected xs <span class="nottickedoff">end</span>)</span>
<span class="lineno">  126 </span><span class="spaces">    </span><span class="istickedoff">| <span class="tickonlytrue">otherwise</span> = x:(hitDetected xs end)</span></span>
<span class="lineno">  127 </span>
<span class="lineno">  128 </span>-- Gets first element i (Int, Int) tuple
<span class="lineno">  129 </span>getFirst :: ([(Int, Int)], [(Int, Int)]) -&gt; [(Int, Int)]
<span class="lineno">  130 </span><span class="decl"><span class="istickedoff">getFirst (a,_) = a</span></span>
<span class="lineno">  131 </span>
<span class="lineno">  132 </span>-- Gets second element i (Int, Int) tuple
<span class="lineno">  133 </span>getSecond :: ([(Int, Int)], [(Int, Int)]) -&gt; [(Int, Int)]
<span class="lineno">  134 </span><span class="decl"><span class="istickedoff">getSecond (_,a) = a</span></span>
<span class="lineno">  135 </span>
<span class="lineno">  136 </span>-- Passes on the state to be checked in a lot of ways
<span class="lineno">  137 </span>errorInState :: State -&gt; Int
<span class="lineno">  138 </span><span class="decl"><span class="istickedoff">errorInState (State (cards, piecesA, piecesB, turn))</span>
<span class="lineno">  139 </span><span class="spaces">    </span><span class="istickedoff">| errorInCards cards = 1</span>
<span class="lineno">  140 </span><span class="spaces">    </span><span class="istickedoff">| <span class="tickonlyfalse">piecesA /= (sortPieces piecesA) &amp;&amp; <span class="nottickedoff">piecesB /= (sortPieces piecesB)</span></span> = <span class="nottickedoff">2</span></span>
<span class="lineno">  141 </span><span class="spaces">    </span><span class="istickedoff">| <span class="tickonlyfalse">(errorInPieces piecesA) || (errorInPieces piecesB)</span> = <span class="nottickedoff">3</span></span>
<span class="lineno">  142 </span><span class="spaces">    </span><span class="istickedoff">| <span class="tickonlyfalse">hasDuplicatePieces (piecesA++piecesB)</span> = <span class="nottickedoff">4</span></span>
<span class="lineno">  143 </span><span class="spaces">    </span><span class="istickedoff">| (turn /= 0) &amp;&amp; (turn /= 1) = 5</span>
<span class="lineno">  144 </span><span class="spaces">    </span><span class="istickedoff">| <span class="tickonlytrue">otherwise</span> = 0</span></span>
<span class="lineno">  145 </span>
<span class="lineno">  146 </span>-- Checks for 5 cards in total
<span class="lineno">  147 </span>errorInCards :: [[Char]] -&gt; Bool
<span class="lineno">  148 </span><span class="decl"><span class="istickedoff">errorInCards [] = <span class="nottickedoff">True</span></span>
<span class="lineno">  149 </span><span class="spaces"></span><span class="istickedoff">errorInCards cards</span>
<span class="lineno">  150 </span><span class="spaces">    </span><span class="istickedoff">| duplicateCards cards = True</span>
<span class="lineno">  151 </span><span class="spaces">    </span><span class="istickedoff">| cards /= (sortCards cards) = True</span>
<span class="lineno">  152 </span><span class="spaces">    </span><span class="istickedoff">| <span class="tickonlyfalse">length cards /= 5</span> = <span class="nottickedoff">True</span></span>
<span class="lineno">  153 </span><span class="spaces">    </span><span class="istickedoff">| <span class="tickonlytrue">otherwise</span> = errorInCards' [getLegalMoves card | card &lt;- cards]</span></span>
<span class="lineno">  154 </span>
<span class="lineno">  155 </span>duplicateCards :: [String] -&gt; Bool
<span class="lineno">  156 </span><span class="decl"><span class="istickedoff">duplicateCards [] = False</span>
<span class="lineno">  157 </span><span class="spaces"></span><span class="istickedoff">duplicateCards (x:xs)</span>
<span class="lineno">  158 </span><span class="spaces">    </span><span class="istickedoff">| elem x xs = True</span>
<span class="lineno">  159 </span><span class="spaces">    </span><span class="istickedoff">| <span class="tickonlytrue">otherwise</span> = duplicateCards xs</span></span>
<span class="lineno">  160 </span>
<span class="lineno">  161 </span>-- Checks if all Cards in state are valid cards
<span class="lineno">  162 </span>-- (Nonvalid names gives an empty list)
<span class="lineno">  163 </span>errorInCards' :: [[(Int, Int)]] -&gt; Bool
<span class="lineno">  164 </span><span class="decl"><span class="istickedoff">errorInCards' [] = False</span>
<span class="lineno">  165 </span><span class="spaces"></span><span class="istickedoff">errorInCards' (card:cards)</span>
<span class="lineno">  166 </span><span class="spaces">    </span><span class="istickedoff">| <span class="tickonlyfalse">null card</span> = <span class="nottickedoff">True</span></span>
<span class="lineno">  167 </span><span class="spaces">    </span><span class="istickedoff">| <span class="tickonlytrue">otherwise</span> = errorInCards' cards</span></span>
<span class="lineno">  168 </span>
<span class="lineno">  169 </span>-- Checks if all pieces have valid coordinates
<span class="lineno">  170 </span>errorInPieces :: [(Int, Int)] -&gt; Bool
<span class="lineno">  171 </span><span class="decl"><span class="istickedoff">errorInPieces [] = False</span>
<span class="lineno">  172 </span><span class="spaces"></span><span class="istickedoff">errorInPieces ((x1, x2):pieces)</span>
<span class="lineno">  173 </span><span class="spaces">    </span><span class="istickedoff">| <span class="tickonlyfalse">(length pieces) &gt; 4</span> = <span class="nottickedoff">True</span></span>
<span class="lineno">  174 </span><span class="spaces">    </span><span class="istickedoff">| <span class="tickonlyfalse">(x1 &lt; 0) || (x2 &lt; 0) || (x1 &gt; 4) || (x2 &gt; 4)</span> = <span class="nottickedoff">True</span></span>
<span class="lineno">  175 </span><span class="spaces">    </span><span class="istickedoff">| <span class="tickonlytrue">otherwise</span> = errorInPieces pieces</span></span>
<span class="lineno">  176 </span>
<span class="lineno">  177 </span>-- Checks if any two pieces are on the same tile on the board
<span class="lineno">  178 </span>hasDuplicatePieces :: [(Int, Int)] -&gt; Bool
<span class="lineno">  179 </span><span class="decl"><span class="istickedoff">hasDuplicatePieces [] = False</span>
<span class="lineno">  180 </span><span class="spaces"></span><span class="istickedoff">hasDuplicatePieces (x:xs)</span>
<span class="lineno">  181 </span><span class="spaces">    </span><span class="istickedoff">| <span class="tickonlyfalse">elem x xs</span> = <span class="nottickedoff">True</span></span>
<span class="lineno">  182 </span><span class="spaces">    </span><span class="istickedoff">| <span class="tickonlytrue">otherwise</span> = hasDuplicatePieces xs</span></span>
<span class="lineno">  183 </span>
<span class="lineno">  184 </span>-- Checks if anything is fundamentally invalid in the move
<span class="lineno">  185 </span>errorInMove :: [[Char]] -&gt; Move -&gt; [(Int, Int)] -&gt; [(Int, Int)] -&gt; Int -&gt; Bool
<span class="lineno">  186 </span><span class="decl"><span class="istickedoff">errorInMove cards (Move (start, end, card)) piecesA piecesB turn</span>
<span class="lineno">  187 </span><span class="spaces">    </span><span class="istickedoff">| <span class="tickonlyfalse">(turn == 0) &amp;&amp; not (elem card (take 2 cards))</span> = <span class="nottickedoff">True</span></span>
<span class="lineno">  188 </span><span class="spaces">    </span><span class="istickedoff">| (turn == 1) &amp;&amp; not (elem card (cards !! 2 :[cards !! 3])) = True</span>
<span class="lineno">  189 </span><span class="spaces">    </span><span class="istickedoff">| <span class="tickonlyfalse">(turn == 0) &amp;&amp; not (elem start piecesA)</span> = <span class="nottickedoff">True</span></span>
<span class="lineno">  190 </span><span class="spaces">    </span><span class="istickedoff">| (turn == 1) &amp;&amp; not (elem start piecesB) = True</span>
<span class="lineno">  191 </span><span class="spaces">    </span><span class="istickedoff">| <span class="tickonlytrue">otherwise</span> = errorInMove' start end (getLegalMoves card) turn</span></span>
<span class="lineno">  192 </span>
<span class="lineno">  193 </span>-- Checks if the move is possible, given the start- and end position,
<span class="lineno">  194 </span>-- and the legal moves of the card played
<span class="lineno">  195 </span>errorInMove' :: (Int, Int) -&gt; (Int, Int) -&gt; [(Int, Int)] -&gt; Int -&gt; Bool
<span class="lineno">  196 </span><span class="decl"><span class="istickedoff">errorInMove' _ _ [] _ = <span class="nottickedoff">True</span></span>
<span class="lineno">  197 </span><span class="spaces"></span><span class="istickedoff">errorInMove' (start1, start2) (end1, end2) ((x1, x2):xs) turn</span>
<span class="lineno">  198 </span><span class="spaces">    </span><span class="istickedoff">| <span class="tickonlyfalse">(end1 &lt; 0) || (end2 &lt; 0) || (end1 &gt; 4) || (end2 &gt; 4)</span> = <span class="nottickedoff">True</span></span>
<span class="lineno">  199 </span><span class="spaces">    </span><span class="istickedoff">| (turn == 0) &amp;&amp; (start1 + x1 == end1) &amp;&amp; (start2 + x2 == end2) = False</span>
<span class="lineno">  200 </span><span class="spaces">    </span><span class="istickedoff">| (turn == 1) &amp;&amp; (start1 - x1 == end1) &amp;&amp; (start2 - x2 == end2) = False</span>
<span class="lineno">  201 </span><span class="spaces">    </span><span class="istickedoff">| <span class="tickonlytrue">otherwise</span> = errorInMove' (start1, start2) (end1, end2) xs turn</span></span>
<span class="lineno">  202 </span>
<span class="lineno">  203 </span>-- Gets legal moves associated with the cards in the game
<span class="lineno">  204 </span>-- empty list, if the String is not a card in the game
<span class="lineno">  205 </span>getLegalMoves :: [Char] -&gt; [(Int, Int)]
<span class="lineno">  206 </span><span class="decl"><span class="istickedoff">getLegalMoves card</span>
<span class="lineno">  207 </span><span class="spaces">    </span><span class="istickedoff">| card == &quot;Rabbit&quot; = [(-1,-1), (1,1), (0,2)]</span>
<span class="lineno">  208 </span><span class="spaces">    </span><span class="istickedoff">| card == &quot;Cobra&quot; = [(0,-1), (1,-1), (1,1)]</span>
<span class="lineno">  209 </span><span class="spaces">    </span><span class="istickedoff">| card == &quot;Rooster&quot; = [(-1,-1), (0,-1), (0,1), (1,1)]</span>
<span class="lineno">  210 </span><span class="spaces">    </span><span class="istickedoff">| card == &quot;Tiger&quot; = [(-1,0), (2, 0)]</span>
<span class="lineno">  211 </span><span class="spaces">    </span><span class="istickedoff">| card == &quot;Monkey&quot; = [(-1,-1), (-1,1), (1,-1), (1,1)]</span>
<span class="lineno">  212 </span><span class="spaces">    </span><span class="istickedoff">| card == &quot;Crab&quot; = [(0,-2), (1,0), (0,2)]</span>
<span class="lineno">  213 </span><span class="spaces">    </span><span class="istickedoff">| card == &quot;Crane&quot; = [(-1,-1), (1,0), (-1,1)]</span>
<span class="lineno">  214 </span><span class="spaces">    </span><span class="istickedoff">| card == &quot;Frog&quot; = [(0,-2), (1,-1), (-1,1)]</span>
<span class="lineno">  215 </span><span class="spaces">    </span><span class="istickedoff">| card == &quot;Boar&quot; = [(0,-1), (0,1), (1,0)]</span>
<span class="lineno">  216 </span><span class="spaces">    </span><span class="istickedoff">| card == &quot;Horse&quot; = [(-1,0), (0,-1), (1,0)]</span>
<span class="lineno">  217 </span><span class="spaces">    </span><span class="istickedoff">| card == &quot;Elephant&quot; = [(1,-1), (0,-1), (0,1), (1,1)]</span>
<span class="lineno">  218 </span><span class="spaces">    </span><span class="istickedoff">| card == &quot;Ox&quot; = [(0,1), (-1,0), (1,0)]</span>
<span class="lineno">  219 </span><span class="spaces">    </span><span class="istickedoff">| card == &quot;Goose&quot; = [(-1,1), (0,-1), (0,1), (1,-1)]</span>
<span class="lineno">  220 </span><span class="spaces">    </span><span class="istickedoff">| card == &quot;Dragon&quot; = [(1,-2), (-1,-1), (-1,1), (1,2)]</span>
<span class="lineno">  221 </span><span class="spaces">    </span><span class="istickedoff">| card == &quot;Mantis&quot; = [(1,-1), (-1,0), (1,1)]</span>
<span class="lineno">  222 </span><span class="spaces">    </span><span class="istickedoff">| <span class="tickonlytrue">card == &quot;Eel&quot;</span> = [(1,-1), (-1,-1), (0,1)]</span>
<span class="lineno">  223 </span><span class="spaces">    </span><span class="istickedoff">| <span class="nottickedoff">otherwise</span> = <span class="nottickedoff">[]</span></span></span>
<span class="lineno">  224 </span>
<span class="lineno">  225 </span>generateRandom :: Int -&gt; Int -&gt; IO (String)
<span class="lineno">  226 </span><span class="decl"><span class="nottickedoff">generateRandom _ _ = return &quot;Not yet implemented&quot;</span></span>
<span class="lineno">  227 </span>-- generateRandom seed n = show (State (cards, piecesA, piecesB))
<span class="lineno">  228 </span>--     where
<span class="lineno">  229 </span>--     cards = getCardNames (getRandomCards seed)
<span class="lineno">  230 </span>--     piecesA = getRandomPieces seed
<span class="lineno">  231 </span>--     piecesB = getRandomPieces (seed*3)
<span class="lineno">  232 </span>-- 
<span class="lineno">  233 </span>-- -- Returns 5 Int values [0 - 15] with no duplicates
<span class="lineno">  234 </span>-- getRandomCards :: Int -&gt; [String]
<span class="lineno">  235 </span>-- getRandomCards seed
<span class="lineno">  236 </span>--     | (seed `mod` 16) == 0 = getRandomCards (seed + 1)
<span class="lineno">  237 </span>--     | hasDuplicateCards cards = getRandomCards (seed + 1)
<span class="lineno">  238 </span>--     | otherwise = cards
<span class="lineno">  239 </span>--     where
<span class="lineno">  240 </span>--         card0 = (seed*seed) `mod` 16
<span class="lineno">  241 </span>--         card1 = (seed*seed*3) `mod` 16
<span class="lineno">  242 </span>--         card2 = (seed*seed*5) `mod` 16
<span class="lineno">  243 </span>--         card3 = (seed*seed*7) `mod` 16
<span class="lineno">  244 </span>--         card4 = (seed*seed*11) `mod` 16
<span class="lineno">  245 </span>--         cards = [card0, card1, card2, card3, card4]
<span class="lineno">  246 </span>-- 
<span class="lineno">  247 </span>-- -- Gets cards names from a index
<span class="lineno">  248 </span>-- -- empty string, if the index is not described  
<span class="lineno">  249 </span>-- getCardNames :: Int -&gt; String
<span class="lineno">  250 </span>-- getCardNames index
<span class="lineno">  251 </span>--     | index == 0  = &quot;Rabbit&quot; 
<span class="lineno">  252 </span>--     | index == 1  = &quot;Cobra&quot; 
<span class="lineno">  253 </span>--     | index == 2  = &quot;Rooster&quot;
<span class="lineno">  254 </span>--     | index == 3  = &quot;Tiger&quot; 
<span class="lineno">  255 </span>--     | index == 4  = &quot;Monkey&quot; 
<span class="lineno">  256 </span>--     | index == 5  = &quot;Crab&quot; 
<span class="lineno">  257 </span>--     | index == 6  = &quot;Crane&quot; 
<span class="lineno">  258 </span>--     | index == 7  = &quot;Frog&quot; 
<span class="lineno">  259 </span>--     | index == 8  = &quot;Boar&quot; 
<span class="lineno">  260 </span>--     | index == 9  = &quot;Horse&quot; 
<span class="lineno">  261 </span>--     | index == 10 = &quot;Elephant&quot; 
<span class="lineno">  262 </span>--     | index == 11 = &quot;Ox&quot; 
<span class="lineno">  263 </span>--     | index == 12 = &quot;Goose&quot; 
<span class="lineno">  264 </span>--     | index == 13 = &quot;Dragon&quot; 
<span class="lineno">  265 </span>--     | index == 14 = &quot;Mantis&quot; 
<span class="lineno">  266 </span>--     | index == 15 = &quot;Eel&quot; 
<span class="lineno">  267 </span>--     | otherwise = &quot;&quot;
<span class="lineno">  268 </span>-- 
<span class="lineno">  269 </span>-- -- Checks if a list of integers have any duplicate values
<span class="lineno">  270 </span>-- hasDuplicateCards :: [Int] -&gt; Bool
<span class="lineno">  271 </span>-- hasDuplicateCards [] = False
<span class="lineno">  272 </span>-- hasDuplicateCards (x:xs)
<span class="lineno">  273 </span>--     | elem x xs = True
<span class="lineno">  274 </span>--     | otherwise = hasDuplicateCards xs
<span class="lineno">  275 </span>-- 
<span class="lineno">  276 </span>-- -- Returns 5 random (Int, Int)
<span class="lineno">  277 </span>-- getRandomPieces :: Int -&gt; [(Int, Int)]
<span class="lineno">  278 </span>-- getRandomPieces seed
<span class="lineno">  279 </span>--     | (seed `mod` 5) == 0 = getRandomPieces (seed + 1)
<span class="lineno">  280 </span>--     | hasDuplicatePieces pieces = getRandomPieces (seed + 1)
<span class="lineno">  281 </span>--     | otherwise = pieces
<span class="lineno">  282 </span>--     where
<span class="lineno">  283 </span>--         piece0 = ((seed `mod` 5), ((seed*3) `mod` 5))
<span class="lineno">  284 </span>--         piece1 = (((seed * 7) `mod` 5), ((seed*9) `mod` 5))
<span class="lineno">  285 </span>--         piece2 = (((seed - 1)`mod` 5), ((seed*13) `mod` 5))
<span class="lineno">  286 </span>--         piece3 = (((seed * 17) `mod` 5), ((seed*2) `mod` 5))
<span class="lineno">  287 </span>--         piece4 = (((seed * 31) `mod` 5), ((seed*71) `mod` 5))
<span class="lineno">  288 </span>--         pieces = [card0, card1, card2, card3, card4]
<span class="lineno">  289 </span>-- 
<span class="lineno">  290 </span>-- removeDuplicates :: [(Int, Int)] -&gt; [(Int, Int)]
<span class="lineno">  291 </span>-- removeDuplicates [] = []
<span class="lineno">  292 </span>-- removeDuplicates (x:xs)
<span class="lineno">  293 </span>--     | elem x xs = xs
<span class="lineno">  294 </span>--     | otherwise = x:(removeDuplicates xs)
<span class="lineno">  295 </span>
<span class="lineno">  296 </span>movesNumbers :: Int -&gt; String -&gt; IO (String)
<span class="lineno">  297 </span><span class="decl"><span class="nottickedoff">movesNumbers _ _ = return &quot;Not yet implemented&quot;</span></span>

</pre>
</body>
</html>
