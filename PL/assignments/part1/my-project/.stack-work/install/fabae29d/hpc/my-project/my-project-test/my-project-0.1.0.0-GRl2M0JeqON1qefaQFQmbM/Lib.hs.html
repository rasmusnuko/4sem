<html>
<head>
<meta http-equiv="Content-Type" content="text/html; charset=CP850">
<style type="text/css">
span.lineno { color: white; background: #aaaaaa; border-right: solid white 12px }
span.nottickedoff { background: yellow}
span.istickedoff { background: white }
span.tickonlyfalse { margin: -1px; border: 1px solid #f20913; background: #f20913 }
span.tickonlytrue  { margin: -1px; border: 1px solid #60de51; background: #60de51 }
span.funcount { font-size: small; color: orange; z-index: 2; position: absolute; right: 20 }
span.decl { font-weight: bold }
span.spaces    { background: white }
</style>
</head>
<body>
<pre>
<span class="decl"><span class="nottickedoff">never executed</span> <span class="tickonlytrue">always true</span> <span class="tickonlyfalse">always false</span></span>
</pre>
<pre>
<span class="lineno">    1 </span>module Lib (
<span class="lineno">    2 </span> generateRandom,
<span class="lineno">    3 </span> isValid,
<span class="lineno">    4 </span> movesNumbers,
<span class="lineno">    5 </span> isValidAux
<span class="lineno">    6 </span> ) where
<span class="lineno">    7 </span>
<span class="lineno">    8 </span>import System.IO
<span class="lineno">    9 </span>import Control.Monad
<span class="lineno">   10 </span>import System.Random
<span class="lineno">   11 </span>import Data.Maybe
<span class="lineno">   12 </span>import Data.List
<span class="lineno">   13 </span>import Text.Read
<span class="lineno">   14 </span>
<span class="lineno">   15 </span>data State = State ([String], [(Int, Int)], [(Int, Int)], Int) deriving (<span class="decl"><span class="istickedoff">Show</span></span>, <span class="decl"><span class="nottickedoff"><span class="decl"><span class="istickedoff"><span class="decl"><span class="nottickedoff">Read</span></span></span></span></span></span>)
<span class="lineno">   16 </span>data Move = Move ((Int, Int), (Int,Int), String) deriving (<span class="decl"><span class="istickedoff">Show</span></span>, <span class="decl"><span class="nottickedoff"><span class="decl"><span class="istickedoff"><span class="decl"><span class="nottickedoff">Read</span></span></span></span></span></span>)
<span class="lineno">   17 </span>
<span class="lineno">   18 </span>-- Parses State and [Moves] from a filePath
<span class="lineno">   19 </span>-- and passes the data to isValidAux
<span class="lineno">   20 </span>isValid :: String -&gt; IO (String)
<span class="lineno">   21 </span><span class="decl"><span class="istickedoff">isValid filePath = do</span>
<span class="lineno">   22 </span><span class="spaces">    </span><span class="istickedoff">contents &lt;- readFile filePath</span>
<span class="lineno">   23 </span><span class="spaces">    </span><span class="istickedoff">let linesAsList = lines contents</span>
<span class="lineno">   24 </span><span class="spaces">    </span><span class="istickedoff">let state = (&quot;State &quot; ++ (head linesAsList))</span>
<span class="lineno">   25 </span><span class="spaces">    </span><span class="istickedoff">let moves = [&quot;Move &quot; ++ x | x &lt;- (tail linesAsList)]</span>
<span class="lineno">   26 </span><span class="spaces">    </span><span class="istickedoff">let maybeState = readMaybe state :: Maybe State</span>
<span class="lineno">   27 </span><span class="spaces">    </span><span class="istickedoff">let maybeMoves = [readMaybe x :: Maybe Move | x &lt;- moves]</span>
<span class="lineno">   28 </span><span class="spaces">    </span><span class="istickedoff">-- Getting maybe state</span>
<span class="lineno">   29 </span><span class="spaces">    </span><span class="istickedoff">if (isNothing maybeState)</span>
<span class="lineno">   30 </span><span class="spaces">    </span><span class="istickedoff">then return &quot;ParsingError&quot;</span>
<span class="lineno">   31 </span><span class="spaces">    </span><span class="istickedoff">-- Getting maybe moves</span>
<span class="lineno">   32 </span><span class="spaces">    </span><span class="istickedoff">else if any (&amp;&amp;True) [isNothing x | x &lt;- maybeMoves]</span>
<span class="lineno">   33 </span><span class="spaces">    </span><span class="istickedoff">then return &quot;ParsingError&quot;</span>
<span class="lineno">   34 </span><span class="spaces">    </span><span class="istickedoff">-- Checking for empty moves list or invalid state</span>
<span class="lineno">   35 </span><span class="spaces">    </span><span class="istickedoff">else if (null maybeMoves)</span>
<span class="lineno">   36 </span><span class="spaces">    </span><span class="istickedoff">then return &quot;ParsingError&quot;</span>
<span class="lineno">   37 </span><span class="spaces">    </span><span class="istickedoff">else if <span class="tickonlyfalse">(errorInState (read state :: State) /= 0)</span></span>
<span class="lineno">   38 </span><span class="spaces">    </span><span class="istickedoff">then <span class="nottickedoff">return &quot;ParsingError&quot;</span></span>
<span class="lineno">   39 </span><span class="spaces">    </span><span class="istickedoff">else return (isValidAux (read state :: State) [ read x :: Move | x &lt;- moves])</span></span> 
<span class="lineno">   40 </span>
<span class="lineno">   41 </span>-- Passes the State and list of Move's on to isValidAux',
<span class="lineno">   42 </span>-- along side a counter used to keep track of the amount of moves played
<span class="lineno">   43 </span>isValidAux :: State -&gt; [Move] -&gt; [Char]
<span class="lineno">   44 </span><span class="decl"><span class="istickedoff">isValidAux state [] = removeFirstWord (show state)</span>
<span class="lineno">   45 </span><span class="spaces"></span><span class="istickedoff">isValidAux (State (cards, piecesA, piecesB, turn)) (move:moves) </span>
<span class="lineno">   46 </span><span class="spaces">    </span><span class="istickedoff">| <span class="tickonlyfalse">(null piecesA || null piecesB) &amp;&amp; <span class="nottickedoff">not (null (move:moves))</span></span> = <span class="nottickedoff">&quot;NonValid &quot; ++ removeFirstWord (show move)</span></span>
<span class="lineno">   47 </span><span class="spaces">    </span><span class="istickedoff">| errorInMove cards move piecesA piecesB turn = &quot;NonValid &quot; ++ removeFirstWord (show move)</span>
<span class="lineno">   48 </span><span class="spaces">    </span><span class="istickedoff">| <span class="tickonlyfalse">errorInState newState /= 0</span> = <span class="nottickedoff">&quot;NonValid &quot; ++ removeFirstWord (show move)</span></span>
<span class="lineno">   49 </span><span class="spaces">    </span><span class="istickedoff">| <span class="tickonlytrue">otherwise</span> = isValidAux newState moves</span>
<span class="lineno">   50 </span><span class="spaces">    </span><span class="istickedoff">where</span>
<span class="lineno">   51 </span><span class="spaces">        </span><span class="istickedoff"><span class="nottickedoff">state = (State (cards, piecesA, piecesB, turn))</span></span>
<span class="lineno">   52 </span><span class="spaces">        </span><span class="istickedoff">newState = applyMove (State (cards, piecesA, piecesB, turn)) move</span></span> 
<span class="lineno">   53 </span>
<span class="lineno">   54 </span>-- Removes everything up to and including the first space
<span class="lineno">   55 </span>removeFirstWord :: [Char] -&gt; String 
<span class="lineno">   56 </span><span class="decl"><span class="istickedoff">removeFirstWord [] = <span class="nottickedoff">[]</span></span>
<span class="lineno">   57 </span><span class="spaces"></span><span class="istickedoff">removeFirstWord (x:xs)</span>
<span class="lineno">   58 </span><span class="spaces">    </span><span class="istickedoff">| (x == ' ') = xs</span>
<span class="lineno">   59 </span><span class="spaces">    </span><span class="istickedoff">| <span class="tickonlytrue">otherwise</span> = removeFirstWord xs</span></span>
<span class="lineno">   60 </span>
<span class="lineno">   61 </span>-- Takes a State and a Move, and returns a new State where the Move has been performed
<span class="lineno">   62 </span>applyMove :: State -&gt; Move -&gt; State
<span class="lineno">   63 </span><span class="decl"><span class="istickedoff">applyMove (State (cards, piecesA, piecesB, turn)) (Move (start, end, card))</span>
<span class="lineno">   64 </span><span class="spaces">    </span><span class="istickedoff">= (State (cards', piecesA', piecesB', turn'))</span>
<span class="lineno">   65 </span><span class="spaces">    </span><span class="istickedoff">where</span>
<span class="lineno">   66 </span><span class="spaces">        </span><span class="istickedoff">cards' = sortCards (swapCards cards card)</span>
<span class="lineno">   67 </span><span class="spaces">        </span><span class="istickedoff">piecesA' = sortPieces (getFirst (applyPieces start end turn piecesA piecesB))</span>
<span class="lineno">   68 </span><span class="spaces">        </span><span class="istickedoff">piecesB' = sortPieces (getSecond (applyPieces start end turn piecesA piecesB))</span>
<span class="lineno">   69 </span><span class="spaces">        </span><span class="istickedoff">turn' = (if turn == 0 then 1 else 0)</span></span>
<span class="lineno">   70 </span>
<span class="lineno">   71 </span>-- Swaps played card with the last card
<span class="lineno">   72 </span><span class="decl"><span class="istickedoff">swapCards (x:xs) card</span>
<span class="lineno">   73 </span><span class="spaces">    </span><span class="istickedoff">| x == card = (last (<span class="nottickedoff">x</span>:xs)):(swapCards xs card)</span>
<span class="lineno">   74 </span><span class="spaces">    </span><span class="istickedoff">| null xs = card:[]</span>
<span class="lineno">   75 </span><span class="spaces">    </span><span class="istickedoff">| <span class="tickonlytrue">otherwise</span> = x:(swapCards xs card)</span></span>
<span class="lineno">   76 </span>
<span class="lineno">   77 </span>-- Sorts first and second, and third and fourth cards, lexicographically repectively
<span class="lineno">   78 </span>sortCards :: [[Char]] -&gt; [[Char]]
<span class="lineno">   79 </span><span class="decl"><span class="istickedoff">sortCards cards = (sort(take 2 cards)) ++ (sort((cards !! 2):(cards !! 3):[])) ++ (last cards):[]</span></span>
<span class="lineno">   80 </span>
<span class="lineno">   81 </span>-- Checks if any player has won
<span class="lineno">   82 </span>applyPieces :: (Int, Int) -&gt; (Int, Int) -&gt; Int -&gt; [(Int, Int)] -&gt; [(Int, Int)] -&gt; ([(Int, Int)], [(Int, Int)])
<span class="lineno">   83 </span><span class="decl"><span class="istickedoff">applyPieces start end turn piecesA piecesB</span>
<span class="lineno">   84 </span><span class="spaces">    </span><span class="istickedoff">| <span class="tickonlyfalse">turn == 0 &amp;&amp; (head newPiecesA) == (4,<span class="nottickedoff">2</span>)</span>  = <span class="nottickedoff">(newPiecesA, [])</span></span>
<span class="lineno">   85 </span><span class="spaces">    </span><span class="istickedoff">| <span class="tickonlyfalse">turn == 1 &amp;&amp; (head newPiecesB) == (0,<span class="nottickedoff">2</span>)</span> = <span class="nottickedoff">([], newPiecesB)</span></span>
<span class="lineno">   86 </span><span class="spaces">    </span><span class="istickedoff">| <span class="tickonlyfalse">turn == 0 &amp;&amp; end == (head newPiecesB)</span> = <span class="nottickedoff">(newPiecesA, [])</span></span>
<span class="lineno">   87 </span><span class="spaces">    </span><span class="istickedoff">| <span class="tickonlyfalse">turn == 1 &amp;&amp; end == (head newPiecesA)</span> = <span class="nottickedoff">([], newPiecesB)</span></span>
<span class="lineno">   88 </span><span class="spaces">    </span><span class="istickedoff">| <span class="tickonlyfalse">turn == 0 &amp;&amp; elem end (tail newPiecesB)</span> = <span class="nottickedoff">(newPiecesA, (hitDetected piecesB end))</span></span>
<span class="lineno">   89 </span><span class="spaces">    </span><span class="istickedoff">| <span class="tickonlyfalse">turn == 1 &amp;&amp; elem end (tail newPiecesA)</span> = <span class="nottickedoff">((hitDetected piecesA end), newPiecesB)</span></span>
<span class="lineno">   90 </span><span class="spaces">    </span><span class="istickedoff">| <span class="tickonlytrue">otherwise</span> = (newPiecesA, newPiecesB)</span>
<span class="lineno">   91 </span><span class="spaces">    </span><span class="istickedoff">where  -- Getting the new positions</span>
<span class="lineno">   92 </span><span class="spaces">        </span><span class="istickedoff">newPiecesA = applyPiecesA start end turn piecesA</span>
<span class="lineno">   93 </span><span class="spaces">        </span><span class="istickedoff">newPiecesB = applyPiecesB start end turn piecesB</span></span>
<span class="lineno">   94 </span>
<span class="lineno">   95 </span>-- Sorts a players pieces lexicographically
<span class="lineno">   96 </span>sortPieces :: [(Int, Int)] -&gt; [(Int, Int)]
<span class="lineno">   97 </span><span class="decl"><span class="istickedoff">sortPieces [] = <span class="nottickedoff">[]</span></span>
<span class="lineno">   98 </span><span class="spaces"></span><span class="istickedoff">sortPieces (x:xs) = x:(sort xs)</span></span>
<span class="lineno">   99 </span>
<span class="lineno">  100 </span>-- Updating player A's pieces
<span class="lineno">  101 </span>applyPiecesA :: (Int, Int) -&gt; (Int, Int) -&gt; Int -&gt; [(Int, Int)] -&gt; [(Int, Int)]
<span class="lineno">  102 </span><span class="decl"><span class="istickedoff">applyPiecesA start end turn piecesA</span>
<span class="lineno">  103 </span><span class="spaces">    </span><span class="istickedoff">| turn == 1 = piecesA</span>
<span class="lineno">  104 </span><span class="spaces">    </span><span class="istickedoff">| <span class="tickonlytrue">otherwise</span> = swapPieces piecesA start end</span></span>
<span class="lineno">  105 </span>
<span class="lineno">  106 </span>-- Updating player B's pieces
<span class="lineno">  107 </span>applyPiecesB :: (Int, Int) -&gt; (Int, Int) -&gt; Int -&gt; [(Int, Int)] -&gt; [(Int, Int)]
<span class="lineno">  108 </span><span class="decl"><span class="istickedoff">applyPiecesB start end turn piecesB</span>
<span class="lineno">  109 </span><span class="spaces">    </span><span class="istickedoff">| turn ==  0 = piecesB</span>
<span class="lineno">  110 </span><span class="spaces">    </span><span class="istickedoff">| <span class="tickonlytrue">otherwise</span> = swapPieces piecesB start end</span></span>
<span class="lineno">  111 </span>
<span class="lineno">  112 </span>-- Swaps start with end and returns the new list
<span class="lineno">  113 </span>swapPieces :: [(Int, Int)] -&gt; (Int, Int) -&gt; (Int, Int) -&gt; [(Int, Int)]
<span class="lineno">  114 </span><span class="decl"><span class="istickedoff">swapPieces [] _ _ = []</span>
<span class="lineno">  115 </span><span class="spaces"></span><span class="istickedoff">swapPieces (x:xs) start end</span>
<span class="lineno">  116 </span><span class="spaces">    </span><span class="istickedoff">| x == start = end:(swapPieces xs start <span class="nottickedoff">end</span>)</span>
<span class="lineno">  117 </span><span class="spaces">    </span><span class="istickedoff">| <span class="tickonlytrue">otherwise</span> = x:(swapPieces xs start end)</span></span>
<span class="lineno">  118 </span>
<span class="lineno">  119 </span>-- Removes a piece from a list
<span class="lineno">  120 </span>hitDetected :: [(Int, Int)] -&gt; (Int, Int) -&gt; [(Int, Int)]
<span class="lineno">  121 </span><span class="decl"><span class="nottickedoff">hitDetected (x:xs) end</span>
<span class="lineno">  122 </span><span class="spaces">    </span><span class="nottickedoff">| null xs = []</span>
<span class="lineno">  123 </span><span class="spaces">    </span><span class="nottickedoff">| x == end = (hitDetected xs end)</span>
<span class="lineno">  124 </span><span class="spaces">    </span><span class="nottickedoff">| otherwise = x:(hitDetected xs end)</span></span>
<span class="lineno">  125 </span>
<span class="lineno">  126 </span>-- Gets first element i (Int, Int) tuple
<span class="lineno">  127 </span>getFirst :: ([(Int, Int)], [(Int, Int)]) -&gt; [(Int, Int)]
<span class="lineno">  128 </span><span class="decl"><span class="istickedoff">getFirst (a,_) = a</span></span>
<span class="lineno">  129 </span>
<span class="lineno">  130 </span>-- Gets second element i (Int, Int) tuple
<span class="lineno">  131 </span>getSecond :: ([(Int, Int)], [(Int, Int)]) -&gt; [(Int, Int)]
<span class="lineno">  132 </span><span class="decl"><span class="istickedoff">getSecond (_,a) = a</span></span>
<span class="lineno">  133 </span>
<span class="lineno">  134 </span>-- Passes on the state to be checked in a lot of ways
<span class="lineno">  135 </span>errorInState :: State -&gt; Int
<span class="lineno">  136 </span><span class="decl"><span class="istickedoff">errorInState (State (cards, piecesA, piecesB, turn))</span>
<span class="lineno">  137 </span><span class="spaces">    </span><span class="istickedoff">| <span class="tickonlyfalse">errorInCards cards</span> = <span class="nottickedoff">1</span></span>
<span class="lineno">  138 </span><span class="spaces">    </span><span class="istickedoff">| <span class="tickonlyfalse">piecesA /= (sortPieces piecesA) &amp;&amp; <span class="nottickedoff">piecesB /= (sortPieces piecesB)</span></span> = <span class="nottickedoff">2</span></span>
<span class="lineno">  139 </span><span class="spaces">    </span><span class="istickedoff">| <span class="tickonlyfalse">(errorInPieces piecesA) || (errorInPieces piecesB)</span> = <span class="nottickedoff">3</span></span>
<span class="lineno">  140 </span><span class="spaces">    </span><span class="istickedoff">| <span class="tickonlyfalse">hasDuplicates (piecesA++piecesB)</span> = <span class="nottickedoff">4</span></span>
<span class="lineno">  141 </span><span class="spaces">    </span><span class="istickedoff">| <span class="tickonlyfalse">(turn /= 0) &amp;&amp; (turn /= 1)</span> = <span class="nottickedoff">5</span></span>
<span class="lineno">  142 </span><span class="spaces">    </span><span class="istickedoff">| <span class="tickonlytrue">otherwise</span> = 0</span></span>
<span class="lineno">  143 </span>
<span class="lineno">  144 </span>-- Checks for 5 cards in total
<span class="lineno">  145 </span>errorInCards :: [[Char]] -&gt; Bool
<span class="lineno">  146 </span><span class="decl"><span class="istickedoff">errorInCards [] = <span class="nottickedoff">True</span></span>
<span class="lineno">  147 </span><span class="spaces"></span><span class="istickedoff">errorInCards cards</span>
<span class="lineno">  148 </span><span class="spaces">    </span><span class="istickedoff">| <span class="tickonlyfalse">cards /= (sortCards cards)</span> = <span class="nottickedoff">True</span></span>
<span class="lineno">  149 </span><span class="spaces">    </span><span class="istickedoff">| <span class="tickonlyfalse">length cards /= 5</span> = <span class="nottickedoff">True</span></span>
<span class="lineno">  150 </span><span class="spaces">    </span><span class="istickedoff">| <span class="tickonlytrue">otherwise</span> = errorInCards' [getLegalMoves card | card &lt;- cards]</span></span>
<span class="lineno">  151 </span>
<span class="lineno">  152 </span>-- Checks if all Cards in state are valid cards
<span class="lineno">  153 </span>-- (Nonvalid names gives an empty list)
<span class="lineno">  154 </span>errorInCards' :: [[(Int, Int)]] -&gt; Bool
<span class="lineno">  155 </span><span class="decl"><span class="istickedoff">errorInCards' [] = False</span>
<span class="lineno">  156 </span><span class="spaces"></span><span class="istickedoff">errorInCards' (card:cards)</span>
<span class="lineno">  157 </span><span class="spaces">    </span><span class="istickedoff">| <span class="tickonlyfalse">null card</span> = <span class="nottickedoff">True</span></span>
<span class="lineno">  158 </span><span class="spaces">    </span><span class="istickedoff">| <span class="tickonlytrue">otherwise</span> = errorInCards' cards</span></span>
<span class="lineno">  159 </span>
<span class="lineno">  160 </span>-- Checks if all pieces have valid coordinates
<span class="lineno">  161 </span>errorInPieces :: [(Int, Int)] -&gt; Bool
<span class="lineno">  162 </span><span class="decl"><span class="istickedoff">errorInPieces [] = False</span>
<span class="lineno">  163 </span><span class="spaces"></span><span class="istickedoff">errorInPieces ((x1, x2):pieces)</span>
<span class="lineno">  164 </span><span class="spaces">    </span><span class="istickedoff">| <span class="tickonlyfalse">length (<span class="nottickedoff">(x1, x2)</span>:pieces) &gt; 5</span> = <span class="nottickedoff">True</span></span>
<span class="lineno">  165 </span><span class="spaces">    </span><span class="istickedoff">| <span class="tickonlyfalse">(x1 &lt; 0) || (x2 &lt; 0) || (x1 &gt; 4) || (x2 &gt; 4)</span> = <span class="nottickedoff">True</span></span>
<span class="lineno">  166 </span><span class="spaces">    </span><span class="istickedoff">| <span class="tickonlytrue">otherwise</span> = errorInPieces pieces</span></span>
<span class="lineno">  167 </span>
<span class="lineno">  168 </span>-- Checks if any two pieces are on the same tile on the board
<span class="lineno">  169 </span>hasDuplicates :: [(Int, Int)] -&gt; Bool
<span class="lineno">  170 </span><span class="decl"><span class="istickedoff">hasDuplicates [] = False</span>
<span class="lineno">  171 </span><span class="spaces"></span><span class="istickedoff">hasDuplicates (x:xs)</span>
<span class="lineno">  172 </span><span class="spaces">    </span><span class="istickedoff">| <span class="tickonlyfalse">elem x xs</span> = <span class="nottickedoff">True</span></span>
<span class="lineno">  173 </span><span class="spaces">    </span><span class="istickedoff">| <span class="tickonlytrue">otherwise</span> = hasDuplicates xs</span></span>
<span class="lineno">  174 </span>
<span class="lineno">  175 </span>-- Checks if anything is fundamentally invalid in the move
<span class="lineno">  176 </span>errorInMove :: [[Char]] -&gt; Move -&gt; [(Int, Int)] -&gt; [(Int, Int)] -&gt; Int -&gt; Bool
<span class="lineno">  177 </span><span class="decl"><span class="istickedoff">errorInMove cards (Move (start, end, card)) piecesA piecesB turn</span>
<span class="lineno">  178 </span><span class="spaces">    </span><span class="istickedoff">| (turn == 0) &amp;&amp; not (elem card (take 2 cards)) = True</span>
<span class="lineno">  179 </span><span class="spaces">    </span><span class="istickedoff">| (turn == 1) &amp;&amp; not (elem card (cards !! 2 :[cards !! 3])) = True</span>
<span class="lineno">  180 </span><span class="spaces">    </span><span class="istickedoff">| <span class="tickonlyfalse">(turn == 0) &amp;&amp; not (elem start piecesA)</span> = <span class="nottickedoff">True</span></span>
<span class="lineno">  181 </span><span class="spaces">    </span><span class="istickedoff">| (turn == 1) &amp;&amp; not (elem start piecesB) = True</span>
<span class="lineno">  182 </span><span class="spaces">    </span><span class="istickedoff">| <span class="tickonlytrue">otherwise</span> = errorInMove' start end (getLegalMoves card) turn</span></span>
<span class="lineno">  183 </span>
<span class="lineno">  184 </span>-- Checks if the move is possible, given the start- and end position,
<span class="lineno">  185 </span>-- and the legal moves of the card played
<span class="lineno">  186 </span>errorInMove' :: (Int, Int) -&gt; (Int, Int) -&gt; [(Int, Int)] -&gt; Int -&gt; Bool
<span class="lineno">  187 </span><span class="decl"><span class="istickedoff">errorInMove' _ _ [] _ = <span class="nottickedoff">True</span></span>
<span class="lineno">  188 </span><span class="spaces"></span><span class="istickedoff">errorInMove' (start1, start2) (end1, end2) ((x1, x2):xs) turn</span>
<span class="lineno">  189 </span><span class="spaces">    </span><span class="istickedoff">| <span class="tickonlyfalse">(end1 &lt; 0) || (end2 &lt; 0) || (end1 &gt; 4) || (end2 &gt; 4)</span> = <span class="nottickedoff">True</span></span>
<span class="lineno">  190 </span><span class="spaces">    </span><span class="istickedoff">| (turn == 0) &amp;&amp; (start1 + x1 == end1) &amp;&amp; (start2 + x2 == end2) = False</span>
<span class="lineno">  191 </span><span class="spaces">    </span><span class="istickedoff">| (turn == 1) &amp;&amp; (start1 - x1 == end1) &amp;&amp; (start2 - x2 == end2) = False</span>
<span class="lineno">  192 </span><span class="spaces">    </span><span class="istickedoff">| <span class="tickonlytrue">otherwise</span> = errorInMove' (start1, start2) (end1, end2) xs turn</span></span>
<span class="lineno">  193 </span>
<span class="lineno">  194 </span>-- Gets legal moves associated with the cards in the game
<span class="lineno">  195 </span>-- empty list, if the String is not a card in the game
<span class="lineno">  196 </span>getLegalMoves :: [Char] -&gt; [(Int, Int)]
<span class="lineno">  197 </span><span class="decl"><span class="istickedoff">getLegalMoves card</span>
<span class="lineno">  198 </span><span class="spaces">    </span><span class="istickedoff">| card == &quot;Rabbit&quot; = [(-1,<span class="nottickedoff">-1</span>), (1,1), <span class="nottickedoff">(0,2)</span>]</span>
<span class="lineno">  199 </span><span class="spaces">    </span><span class="istickedoff">| card == &quot;Cobra&quot; = [(0,<span class="nottickedoff">-1</span>), (1,-1), (1,1)]</span>
<span class="lineno">  200 </span><span class="spaces">    </span><span class="istickedoff">| card == &quot;Rooster&quot; = [(-1,<span class="nottickedoff">-1</span>), (0,<span class="nottickedoff">-1</span>), (0,<span class="nottickedoff">1</span>), (1,1)]</span>
<span class="lineno">  201 </span><span class="spaces">    </span><span class="istickedoff">| card == &quot;Tiger&quot; = [(-1,<span class="nottickedoff">0</span>), (2, 0)]</span>
<span class="lineno">  202 </span><span class="spaces">    </span><span class="istickedoff">| <span class="tickonlytrue">card == &quot;Monkey&quot;</span> = [(-1,<span class="nottickedoff">-1</span>), (-1,<span class="nottickedoff">1</span>), (1,-1), (1,1)]</span>
<span class="lineno">  203 </span><span class="spaces">    </span><span class="istickedoff">| <span class="nottickedoff">card == &quot;Crab&quot;</span> = <span class="nottickedoff">[(0,-2), (1,0), (0,2)]</span></span>
<span class="lineno">  204 </span><span class="spaces">    </span><span class="istickedoff">| <span class="nottickedoff">card == &quot;Crane&quot;</span> = <span class="nottickedoff">[(-1,-1), (1,0), (-1,1)]</span></span>
<span class="lineno">  205 </span><span class="spaces">    </span><span class="istickedoff">| <span class="nottickedoff">card == &quot;Frog&quot;</span> = <span class="nottickedoff">[(0,-2), (1,-1), (-1,1)]</span></span>
<span class="lineno">  206 </span><span class="spaces">    </span><span class="istickedoff">| <span class="nottickedoff">card == &quot;Boar&quot;</span> = <span class="nottickedoff">[(0,-1), (0,1), (1,0)]</span></span>
<span class="lineno">  207 </span><span class="spaces">    </span><span class="istickedoff">| <span class="nottickedoff">card == &quot;Horse&quot;</span> = <span class="nottickedoff">[(-1,0), (0,-1), (1,0)]</span></span>
<span class="lineno">  208 </span><span class="spaces">    </span><span class="istickedoff">| <span class="nottickedoff">card == &quot;Elephant&quot;</span> = <span class="nottickedoff">[(1,-1), (0,-1), (0,1), (1,1)]</span></span>
<span class="lineno">  209 </span><span class="spaces">    </span><span class="istickedoff">| <span class="nottickedoff">card == &quot;Ox&quot;</span> = <span class="nottickedoff">[(0,1), (-1,0), (1,0)]</span></span>
<span class="lineno">  210 </span><span class="spaces">    </span><span class="istickedoff">| <span class="nottickedoff">card == &quot;Goose&quot;</span> = <span class="nottickedoff">[(-1,1), (0,-1), (0,1), (1,-1)]</span></span>
<span class="lineno">  211 </span><span class="spaces">    </span><span class="istickedoff">| <span class="nottickedoff">card == &quot;Dragon&quot;</span> = <span class="nottickedoff">[(1,-2), (-1,-1), (-1,1), (1,2)]</span></span>
<span class="lineno">  212 </span><span class="spaces">    </span><span class="istickedoff">| <span class="nottickedoff">card == &quot;Mantis&quot;</span> = <span class="nottickedoff">[(1,-1), (-1,0), (1,1)]</span></span>
<span class="lineno">  213 </span><span class="spaces">    </span><span class="istickedoff">| <span class="nottickedoff">card == &quot;Eel&quot;</span> = <span class="nottickedoff">[(1,-1), (-1,-1), (0,1)]</span></span>
<span class="lineno">  214 </span><span class="spaces">    </span><span class="istickedoff">| <span class="nottickedoff">otherwise</span> = <span class="nottickedoff">[]</span></span></span>
<span class="lineno">  215 </span>
<span class="lineno">  216 </span>isValid' :: FilePath -&gt; IO (String)
<span class="lineno">  217 </span><span class="decl"><span class="nottickedoff">isValid' _ = return &quot;ParsingError&quot;</span></span>
<span class="lineno">  218 </span>
<span class="lineno">  219 </span>generateRandom :: Int -&gt; Int -&gt; IO (String)
<span class="lineno">  220 </span><span class="decl"><span class="nottickedoff">generateRandom _ _ = return &quot;Not yet implemented&quot;</span></span>
<span class="lineno">  221 </span>
<span class="lineno">  222 </span>movesNumbers :: Int -&gt; String -&gt; IO (String)
<span class="lineno">  223 </span><span class="decl"><span class="nottickedoff">movesNumbers _ _ = return &quot;Not yet implemented&quot;</span></span>

</pre>
</body>
</html>
